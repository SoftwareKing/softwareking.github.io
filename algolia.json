[{"author":"许进","categories":"Nacos","content":" 1. Nacos 升级背景 随着公司业务的快速发展，产品的服务化和平台化在高速建设和迭代之中 。而 Java 技术栈为主的技术体系，搭建平台化和服务化，需要注册中心，经过技术选型之后我们选择了 Nacos 作为注册中心。至于什么是 Nacos，本文不做更多阐述，有兴趣的小伙伴可以借助谷歌搜索引擎快速了解。\n目前公司技术体系主要以 Python 和 Java 为主。但是 Python 服务会通过 Nacos 进行服务注册与发现调用Java服务。两套技术体系的存在，多多少少会存在一些问题。比如 Python 版的 Nacos 客户端服务注册时和Java版 Nacos 客户端(Spring Cloud Alibaba 中封装的 Nacos 客户端)服务注册就不太一样。 Nacos 升级的原因主要是Python服务注册时的元数据，被Java客户端用于服务发现，过滤的时候引起NPE异常，还有就是借此机会统一 Nacos 服务注册发现的客户端基线。\n2. Nacos 升级 2.1 Nacos 升级版本的选择 由于空指针异常是 2020 年 6 月 19 号之后被 Fix，考虑到 Nacos 2.0不是很稳定，因此将 Nacos 升级到 1.4.1 版本是当前最佳选择。\n目前公司使用 Spring Cloud 构建微服务体系，Spring Cloud 版本主要是 H.SR4。此次升级需要把 Nacos Server 升级到 1.4.1 版本。经查看源码，得知 Spring Cloud Alibaba 2.2.5.RELEASE 是基于Spring Cloud H.SR8版本和 Nacos Client 1.4.1版本构建，经过统计分析，当前大多数业务应用是基于H.SR4版本构建，升级到H.SR8版本可以平滑过渡。\n因此综合考虑，选择将 Spring Cloud 基线统一到 Spring Cloud H.SR8 版本，从而最终统一 Spring Boot 和 Spring Cloud 基线。\n2.2 Nacos 升级方案的选择 Nacos 升级方案比较简单，首先升级 follower，最后升级 leader，在升级的过程中，日志中会有一些少量报错(比如：com.netflix.client.ClientException: Load balancer does not have available server for client)，但是正常的，等到全部升级完成之后，达到稳态，就不会报错。\n3. Nacos 升级出错 Nacos 升级过程全程按照升级方案快速升级，在开发环境，测试环境和预发环境都已顺利升级。 但在升级线上环境时，升级之后发现 Nacos Server 服务列表出现空白，空白列表页如下图所示，通过F12查看网络请求，显示当前Nacos集群不可用。\n通过查看可以看到，leader为null，如下图所示: 之后发现大量服务报错，选择回滚回 Nacos 1.1.4版本。回滚之后出现部分服务掉线，并且不会自动注册上来。 最后通过重启掉线服务，重新把服务注册上来了。 这里主要两个疑点： 1. 为什么升级后服务列表会为空？ 2. 回滚后，为什么部分服务无法通过心跳机制自动注册上来，必须通过重启服务才能注册到 nacos 上？\n4. Nacos 升级失败排查 4.1 Nacos 升级失败排查 Nacos 升级失败之后，排查思路刚开始主要是分析 Nacos Server 和 Nacos Client 日志。\n4.1.1 Nacos Server初步日志排查 首先分析的是 Nacos Server中的日志，Nacos Server 主要的需要关注的日志列表如下截图所示:\n在 Server 端 access log 里发现不少心跳请求的 400 错误:\n10.19.169.55 - - [12/May/2021:00:00:00 +0800] \u0026amp;quot;PUT /nacos/v1/ns/instance/beat?app=unknown\u0026amp;amp;serviceName=xxx%40%40xxx-server\u0026amp;amp;namespaceId=public\u0026amp;amp;port=60600\u0026amp;amp;clusterName=DEFAULT\u0026amp;amp;ip=10.19.178.160 HTTP/1.1\u0026amp;quot; 400 26 0 Nacos-Java-Client:v1.4.1,Nacos-Server:1.1.4 10.19.21.39 - - [12/May/2021:00:00:00 +0800] \u0026amp;quot;PUT /nacos/v1/ns/instance/beat?app=unknown\u0026amp;amp;serviceName=xxx%40%40xxx-server\u0026amp;amp;namespaceId=public\u0026amp;amp;port=60600\u0026amp;amp;clusterName=DEFAULT\u0026amp;amp;ip=10.19.178.160 HTTP/1.1\u0026amp;quot; 400 26 0 Nacos-Java-Client:v1.4.1,Nacos-Server:1.1.4 10.19.169.55 - - [12/May/2021:00:00:00 +0800] \u0026amp;quot;PUT /nacos/v1/ns/instance/beat?app=unknown\u0026amp;amp;serviceName=xxx%40%40xxx-server\u0026amp;amp;namespaceId=public\u0026amp;amp;port=60600\u0026amp;amp;clusterName=DEFAULT\u0026amp;amp;ip=10.19.178.160 HTTP/1.1\u0026amp;quot; 400 26 1 Nacos-Java-Client:v1.4.1,Nacos-Server:1.1.4  这里可以看到出错的心跳里，nacos 的客户端是 v1.4.1 版本，高于服务端的 1.1.4。\n Lesson Learn: 中间件的客户端版本需要管控，保持和服务端的版本一致。\n 4.1.2 Nacos Client 初步日志排查 带着这个线索，我们查看报错服务的 nacos client 日志。 Nacos 客户端的日志一般存在 ~/logs/nacos 目录下，如下截图所示:\n查看 Nacos Client 的 naming.log 文件发现示例报错日志如下截图所示:\n可以看出 Nacos Client 发送心跳日志报错，通过观察生产上其它服务均发现类似报错，说明 Nacos Client向 Nacos Server发送心跳经常失败。但是心跳失败，服务却一直健在，没有被T掉，这个原因需要进一步排查落实。 其实上述报错一直存在，没有被发现的原因是平台化前期主要关注了业务应用日志，对于中间件客户端日志没有得到足够的关注\n Nacos 作为中间件，不管是 Nacos Server或 Nacos Client 都应该将所有日志通过ELK收集，并实时监控告警.\n 根据 nacos server 和 client 端的日志线索，我们找到 nacos 官方的一个 issue : Param …","date":1623391200,"description":"Nacos Server 升级至 1.4.1 版本踩坑分析","dir":"blog/nacos/nacos-upgrade/","fuzzywordcount":4800,"kind":"page","lang":"zh","lastmod":1623391200,"objectID":"81e276843b6a40cb2982ec9ad1bcd2a7","permalink":"/blog/nacos/nacos-upgrade/","publishdate":"2021-06-11T14:00:00+08:00","readingtime":10,"relpermalink":"/blog/nacos/nacos-upgrade/","summary":"1. Nacos 升级背景 随着公司业务的快速发展，产品的服务化和平台化在高速建设和迭代之中 。而 Java 技术栈为主的技术体系，搭建平台化和服务化，需要注册中心，经","tags":["Nacos升级"],"title":"《Nacos Server 升级至 1.4.1 版本踩坑分析》","type":"blog","url":"/blog/nacos/nacos-upgrade/","wordcount":4799},{"author":null,"categories":null,"content":" 1.Unico Framework概述 Unico(独角兽),本人养了多年的独角兽。是一套融合了基础架构，应用架构，中台架构的生态体系。\n2.如何使用Unico  1.引入Unico相关Starter  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.xujin.halo\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;halo-starter-unico\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.0.0-SNAPSHOT\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   2. 在YMl文件中配置插件的扫描路径  halo: unico: scanPackages: - org.xujin.unico.demo   3. 关键的xml文件配置  关键属性解释： * business-config： 指明市场线/行业线；\n extension-config：扩展点约束定义：\n template-config: 业务身份的某个维度对扩展点的实现，由于市场线/行业线可以与多个产品线重叠，而且市场线/行业线和产品线都是业务身份的一个维度，所以一business-config必然包含1个行业线template-config和N个产品线template-config。\n conflict-priorities：处理某个特定的拓展点在某个维度的业务身份实现\n  核心注解的设计   @Product -产品 @Domain - 领域 @DomainService - 领域服务 @Ability - 领域服务的能力 @AbilityExtension - 能力扩展点 @TemplateExt - 扩展点实现配置  ","date":1595203200,"description":"","dir":"projects/unico/overview/","fuzzywordcount":500,"kind":"page","lang":"zh","lastmod":1595203200,"objectID":"25158a0e32b1f0508619484711e0cc8d","permalink":"/projects/unico/overview/","publishdate":"2020-07-20T00:00:00Z","readingtime":1,"relpermalink":"/projects/unico/overview/","summary":"1.Unico Framework概述 Unico(独角兽),本人养了多年的独角兽。是一套融合了基础架构，应用架构，中台架构的生态体系。 2.如何使用Unic","tags":null,"title":"Unico介绍","type":"projects","url":"/projects/unico/overview/","wordcount":401},{"author":null,"categories":null,"content":" 1. Halo Studio概述 Halo Studio 基于开源的 IntelliJ Platform进行定制开发扩展，将Halo Toolkit内置其中增强,提供企业级IDE支持。\n","date":1589241600,"description":"","dir":"projects/halo-studio/overview/","fuzzywordcount":100,"kind":"page","lang":"zh","lastmod":1589241600,"objectID":"e285836ef2ec471af916cf6219bb08cb","permalink":"/projects/halo-studio/overview/","publishdate":"2020-05-12T00:00:00Z","readingtime":1,"relpermalink":"/projects/halo-studio/overview/","summary":"1. Halo Studio概述 Halo Studio 基于开源的 IntelliJ Platform进行定制开发扩展，将Halo Toolkit内置其中增强,提供企业级IDE支持。","tags":null,"title":"Halo Studio概述","type":"projects","url":"/projects/halo-studio/overview/","wordcount":65},{"author":"许进","categories":"Muse","content":" 本文主要记录在阿里云ECS上安装配置Ngnix，通过公网域名访问多个Spring Boot应用。\n1.安装Ngnix 1.yum安装Nginx\nsudo yum install -y nginx  2.启动Nginx\nsystemctl start nginx.service  3.开机启动Nginx\nsystemctl enable nginx.service  2. Ngnix的常用命令 1.nginx -t 查看Ngnix的配置文件位置\n[root@iZm5ei42hq2wbmbr6yb489Z ~]# nginx -t nginx: the configuration file /etc/nginx/nginx.conf syntax is ok nginx: configuration file /etc/nginx/nginx.conf test is successful  2.启动Ngnix\n[root@iZm5ei42hq2wbmbr6yb489Z nginx]# nginx  3.停止Ngnix\n[root@iZm5ei42hq2wbmbr6yb489Z nginx]# nginx -s stop  3. Ngnix配置总结 3.1 Nginx配置访问多个Spring Boot Jar 1.配置域名a.qingcloud.net访问端口为8080的应用\nserver { listen 80; server_name a.qingcloud.net; location / { proxy_pass http://127.0.0.1:8080; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Forwarded-Port $server_port; } }  2.配置域名b.qingcloud.net访问端口为8082的Spring Boot的应用\nserver { listen 80; server_name b.qingcloud.net; location / { proxy_pass http://127.0.0.1:8082; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Forwarded-Port $server_port; } }  3.2 Ngnix配置访问静态资源 配置域名c.qingcloud.net访问某个文件夹下面的静态资源\nserver { listen 80; #暴露给外部访问的端口 server_name c.qingcloud.net; charset utf-8; location / { #项目静态路径设置 alias /usr/xujin/halo/; } }  4.编写shell命令启动Spring Boot jar 4.1启动可执行Jar sh halo-admin-mgmt.sh start  4.2 对应的shell脚本如下 #!/bin/bash APP_NAME=/usr/xujin/jar/halo-admin-start-1.0.0.RELEASE.jar #使用说明，用来提示输入参数 usage() { echo \u0026amp;quot;Usage: sh halo-admin-mgmt.sh [start|stop|restart|status]\u0026amp;quot; exit 1 } #检查程序是否在运行 is_exist(){ pid=`ps -ef|grep $APP_NAME|grep -v grep|awk \u0026#39;{print $2}\u0026#39;` #如果不存在返回1，存在返回0 if [ -z \u0026amp;quot;${pid}\u0026amp;quot; ]; then return 1 else return 0 fi } #启动方法 start(){ is_exist if [ $? -eq 0 ]; then echo \u0026amp;quot;${APP_NAME} is already running. pid=${pid}\u0026amp;quot; else nohup java -jar ${APP_NAME} \u0026amp;gt;halo-admin.out 2\u0026amp;gt;\u0026amp;amp;1 \u0026amp;amp; fi } #停止方法 stop(){ is_exist if [ $? -eq \u0026amp;quot;0\u0026amp;quot; ]; then kill -9 $pid else echo \u0026amp;quot;${APP_NAME} is not running\u0026amp;quot; fi } #输出运行状态 status(){ is_exist if [ $? -eq \u0026amp;quot;0\u0026amp;quot; ]; then echo \u0026amp;quot;${APP_NAME} is running. Pid is ${pid}\u0026amp;quot; else echo \u0026amp;quot;${APP_NAME} is NOT running.\u0026amp;quot; fi } #重启 restart(){ stop sleep 5 start } #根据输入参数，选择执行对应方法，不输入则执行使用说明 case \u0026amp;quot;$1\u0026amp;quot; in \u0026amp;quot;start\u0026amp;quot;) start ;; \u0026amp;quot;stop\u0026amp;quot;) stop ;; \u0026amp;quot;status\u0026amp;quot;) status ;; \u0026amp;quot;restart\u0026amp;quot;) restart ;; *) usage ;; esac  ","date":1582808400,"description":"本文主要记录在阿里云ECS上安装配置Ngnix，通过公网域名访问多个Spring Boot应用","dir":"muse/","fuzzywordcount":700,"kind":"page","lang":"zh","lastmod":1582808400,"objectID":"87078d8f967a12b35d0a3b1fb776da5d","permalink":"/muse/1/","publishdate":"2020-02-27T21:00:00+08:00","readingtime":2,"relpermalink":"/muse/1/","summary":"本文主要记录在阿里云ECS上安装配置Ngnix，通过公网域名访问多个Spring Boot应用。 1.安装Ngnix 1.yum安装Nginx sudo yum","tags":["Ngnix"],"title":"ECS中配置公网域名访问多个Spring Boot应用","type":"muse","url":"/muse/1/","wordcount":665},{"author":"许进","categories":"Mybatis","content":" 1.背景 项目中经常出现因为Mybatis的动态where条件不满足导致实际sql语句的where条件为空,进而查询全表,当数据量比较大的时候,导致OOM的情况。比如当用户表的数据量为4千万时,如果load全表数据量将会导致OOM，如下图所示,为了解决这种情况基于Mybatis Plus自定义Interceptor实现统一的拦截。\n2.开发 Halo Mybatis从1.2版本开始将会，增加如下的功能:\n 对空Where进行拦截判断\n 并支持开关关闭空where拦截\n 支持白名单设置,即在白名单中的表名将不会进行拦截\n 支持多数据源进行拦截check\n  2.1 核心代码实现 import com.baomidou.mybatisplus.core.toolkit.CollectionUtils; import com.baomidou.mybatisplus.core.toolkit.PluginUtils; import com.baomidou.mybatisplus.core.toolkit.StringUtils; import com.baomidou.mybatisplus.extension.handlers.AbstractSqlParserHandler; import com.google.common.collect.Sets; import org.xujin.halo.mybatis.properties.HaloMybatisProperties; import lombok.extern.slf4j.Slf4j; import org.apache.ibatis.executor.statement.StatementHandler; import org.apache.ibatis.mapping.MappedStatement; import org.apache.ibatis.plugin.*; import org.apache.ibatis.reflection.MetaObject; import org.apache.ibatis.reflection.SystemMetaObject; import java.lang.reflect.InvocationTargetException; import java.sql.Connection; import java.util.List; import java.util.Properties; import java.util.Set; /** * 当Mybatis SQL出现空where并拦截 * @author xujin */ @Intercepts({ @Signature(type = StatementHandler.class, method = \u0026amp;quot;prepare\u0026amp;quot;, args = { Connection.class, Integer.class })}) @Slf4j public class HaloEmptyWhereInterceptor extends AbstractSqlParserHandler implements Interceptor { private HaloMybatisProperties haloMybatisProperties; public HaloEmptyWhereInterceptor(HaloMybatisProperties haloMybatisProperties) { this.haloMybatisProperties=haloMybatisProperties; } /** * 拦截的 COMMAND 类型 */ private static final Set\u0026amp;lt;String\u0026amp;gt; INTERCEPTOR_COMMAND = Sets.newHashSet(\u0026amp;quot;select\u0026amp;quot;, \u0026amp;quot;update\u0026amp;quot;, \u0026amp;quot;delete\u0026amp;quot;); /** * sql中的where关键字 */ private static final String WHERE=\u0026amp;quot;where\u0026amp;quot;; @Override public Object intercept(Invocation invocation) throws Throwable { String originSql = \u0026amp;quot;\u0026amp;quot;; try { StatementHandler handler = PluginUtils.realTarget(invocation.getTarget()); MetaObject metaObject = SystemMetaObject.forObject(handler); // SQL 解析 this.sqlParser(metaObject); MappedStatement mappedStatement = (MappedStatement) metaObject.getValue(\u0026amp;quot;delegate.mappedStatement\u0026amp;quot;); //获取当前的Statement的ID String mappedStatementId = mappedStatement.getId(); log.info(\u0026amp;quot;Halo Mybatis check Empty Where StatementId Is:{} \u0026amp;quot;,mappedStatementId); List\u0026amp;lt;String\u0026amp;gt; whiteList=haloMybatisProperties.getEmptyWhereWhiteList(); if(CollectionUtils.isNotEmpty(whiteList)){ //在白名单中不进行check if(whiteList.contains(mappedStatementId)) { return invocation.proceed(); } } //获取SqlCommandType String commandType = getCommandType(handler); if (!INTERCEPTOR_COMMAND.contains(commandType)) { return invocation.proceed(); } //获取执行的sql判断sql是否包含where String sql=handler.getBoundSql().getSql(); if(StringUtils.isEmpty(sql)){ return invocation.proceed(); } originSql = sql.toLowerCase(); } catch (InvocationTargetException e) { log.error(\u0026amp;quot;halo check EmptyWhere fail!\u0026amp;quot;,e); } catch …","date":1579413600,"description":"项目中经常出现因为Mybatis的动态where条件不满足导致实际sql语句的where条件为空,进而查询全表,当数据量比较大的时候,导致OOM的情况。比如当用户表的数据量为4千万时,如果load全表数据量将会导致OOM，为了解决这种情况基于Mybatis Plus自定义Interceptor实现统一的拦截本篇文章主要介绍基于MyBatis Plus扩展进行Empty Where拦截，避免查询全表出现OOM","dir":"blog/mybatis/2/","fuzzywordcount":1000,"kind":"page","lang":"zh","lastmod":1579413600,"objectID":"eb7b1d198c6f4a535a61588c10078d4a","permalink":"/blog/mybatis/2/","publishdate":"2020-01-19T14:00:00+08:00","readingtime":2,"relpermalink":"/blog/mybatis/2/","summary":"1.背景 项目中经常出现因为Mybatis的动态where条件不满足导致实际sql语句的where条件为空,进而查询全表,当数据量比较大的时候","tags":["Myabtis","项目经验"],"title":"基于MyBatis Plus扩展对Empty Where拦截","type":"blog","url":"/blog/mybatis/2/","wordcount":931},{"author":"许进","categories":"中间件","content":" 1.基础架构职责  设计和开发新一代的基础组件，为重构项目提供技术平台 设计和构建统一的应用开发框架，提高应用开发效率和质量 建立统一的应用构建标准，为实现对应用的管理，监控和治理的自动化建立基础 评估和引进各种国外先进技术，提高公司平台的技术水准 建立公司的开源项目，对内部开发的含金量高的项目实现开源，以提高公司的知名度  这些技术解决方案包括：\n 统一的服务化框架体系  服务化是IT技术架构升级改造的核心内容，提供统一的完整的服务化框架体系尤为重要，该体系为构建“分布式服务架构”提供了技术平台，它涵盖了构建和管理一个服务的整个生命周期所需的各种框架和工具。\n 移动客户端和服务端中间层框架  随着越来越多的用户使用移动App购物，快速研发不同的移动App十分重要，因此构建统一的移动客户端和服务端中间层框架就十分有意义，它不仅能加快移动App的研发，也为提高移动App的产品质量提供了保障。\n 系统集成组件—消息总线  随着互联网应用平台包含各种各样的应用，各应用之间需要保持不同形式的信息交换，有些是同步的，有些是异步的，系统集成组件—消息总线则提供了一组组件以满足应用之间异步通讯之需要。\n服务的授权，监控和治理 随着系统变得越来越大，越来越复杂，服务数目越来越多，如何对该庞大的系统进行有效的管理，安全的管控以及服务质量的监控就非常重要，因此需要有一整套的工具确保监控，授权和服务的治理。\n2. 中间件整理    名称 分类 是否推荐 备注     Halo 中台应用框架 Y 基于DDD+CQRS+扩展点+应用内部流程编排一套的中台落地解决方案   Dubbo RPC框架 Y    Apollo 配置中心 Y    Janus 网关 Y    Nacos 注册中心 Y    DDMq 消息中间件  kafka与Rocketmq的代理   Bistoury 线上问题诊断工具 Y Bistoury是去哪儿网的java应用生产问题诊断工具，提供了一站式的问题诊断方案   Nacos 配置中心 Y    DAS 数据库中间件 Y 拍拍贷DAS是拍拍贷自研的数据库访问框架。   pmq 消息中间件  PMQ是拍拍贷研发一款分布式消息队列，能够保证消息的不丢失，具有部署和运维简单的特性。    ","date":1573714800,"description":"基础架构及中间件体系概述","dir":"blog/mw/2/","fuzzywordcount":900,"kind":"page","lang":"zh","lastmod":1573714800,"objectID":"e3e3c00940e0e3e0ac26462e21cc8d81","permalink":"/blog/mw/2/","publishdate":"2019-11-14T15:00:00+08:00","readingtime":2,"relpermalink":"/blog/mw/2/","summary":"1.基础架构职责 设计和开发新一代的基础组件，为重构项目提供技术平台 设计和构建统一的应用开发框架，提高应用开发效率和质量 建立统一的应用构建标准","tags":["中间件"],"title":"基础架构及中间件体系概述","type":"blog","url":"/blog/mw/2/","wordcount":820},{"author":"许进","categories":"Nacos","content":" 1.背景 Nacos与Eureka相比，Nacos的优点非常明显，当然首选Nacos作为注册中心。本文主要介绍如何从Eureka无缝平滑迁移到Nacos注册中心，业务方应用改动最小，业务应用改造一次完成迁移。\n2.方案设计 2.1 业务应用多注册到Nacos和Eureka Spring Cloud应用默认不支持启动时双向注册，但是阿里商业版上云edas-sc-migration-starter组件支持。可以采用如下的方式引入依赖实现多注册和订阅。\n\u0026amp;lt;!-- https://mvnrepository.com/artifact/com.alibaba.edas/edas-sc-migration-starter --\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alibaba.edas\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;edas-sc-migration-starter\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;1.0.2\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   也就是引入对应的组件，当应用启动的时候同时向Eureka和Nacos实现双向注册。更多的实现细节和使用细节本文将不进行展开。\n 如上图所示，如果只把旧应用只改一部分，会出现只有改造的应用能调到新应用。未改造的应用会出现调不到新应用的情况。即，需要如下图所示的方式，旧应用全部升级改造为双注册到注册中心，才可以支持。\n\u0026amp;gt;但是旧应用无法保证同一时刻全部升级改造为同时注册，因此该方案论证失败。\n2.2 Nacos Sync方案 Nacos Sync 是一个支持多种注册中心的同步组件，基于 SpringBoot 开发框架，数据层采用 Spring Data JPA，遵循了标准的 JPA 访问规范，支持多种数据源存储，默认使用 Hibernate 实现，更加方便的支持表的自动创建更新。但目前最新版本是如下图所示。  跟Nacos Sync项目的负责人沟通过，目前也支持Nacos与Eureka之间双向同步，至于怎么用优缺点怎么样本文将不进行展开。\n 2.3 注册中心服务端双向同步 2.3.1 方案设计 设计思路是注册中心服务端进行双向同步，做到微服务端完全无侵入，可以随业务迭代逐步完成升级和迁移。改造Eureka Server，Eureka Server引入同步组件实现Nacos和Eureka之间实现双向同步，如下图所示：\n2.3.2 迁移步骤 迁移步骤如下:\n 1.部署Nacos Server集群用于服务注册与发现\n 2.在线动态扩容Eureka Server，替换其中的1-2两台Eureka Server。\n 3.逐渐改造旧应用，只需将新旧应用注册到Nacos上\n 4.等旧应用全部改造完毕，下线Eureka Server即可。\n  这样方案的优点，如下:\n 1.新应用直接注册到Nacos上，不需要同时注册到Eureka和Nacos上\n 2.旧应用直接改造(引入相关starter即可)注册到Nacos上即可，不需要同时注册到Nacos和Eureka上\n 3.迁移成本很低，旧应用只需改造一次(所谓的改造即引入新的Starter，修改配置)，等全部旧应用迁移完毕，直接下线Eureka Server。\n  3.迁移落地 3.1 组件开发 开发一个Spring Boot Starter,加入到Eureka Server或Nacos Server中可以实现双向注册。\n3.2 spring-cloud-nacos组件介绍  spring-cloud-nacos主要由何鹰和瞿礼贡献，\n Nacos Plus在Nacos上做加法，Nacos client默认是支持安全控制的可以参考阿里云商业版配置中心ACM集成方式 https://github.com/alibaba/spring-cloud-alibaba/wiki/ACM 以及 spring cloud alibaba 配置项 https://github.com/alibaba/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-examples/nacos-example/nacos-config-example/readme-zh.md 但是开源的Nacos并不含有安全控制模块，在Nacos plus里我们新增了兼容默认Nacos client的安全控制功能。\n   可以查看:https://github.com/inacos/nacos\n 核心代码主要是NacosSynchronizer.java和EurekaSynchronizer.java,请自行阅读。 github地址:https://github.com/inacos/spring-cloud-nacos 4.实现迁移落地 按如下，迁移步骤进行迁移。具体细节在本文省略。 1.部署Nacos Server集群用于服务注册与发现 2.在线动态扩容一台Eureka Server 3.逐渐改造旧应用，只需将新旧应用注册到Nacos上 4.等旧应用全部改造完毕，下线Eureka Server即可。\n下面将在本地进行测试说明，用到的演示说明列表如下所示:\n   服务 说明     Eureka注册中心(http://eureka.springcloud.cn/) 模拟生产上的Eureka注册中心   本地基于源码方式启动一个Nacos实例 模拟生产上新建的Nacos   同步服务(本地基于Eureka Server扩展启动的同步服务） 模拟生产上启动了一个Nacos与Eureka之间双向同步的服务   本地启动一个服务注册到(http://eureka.springcloud.cn/） 验证从eureka同步服务到nacos   本地启动一个服务注册到Nacos 验证从nacos同步服务到Eureka上    4.1 模拟生产上的注册中心 Spring Cloud中国社区公网上有个Eureka注册中心，地址为:http://eureka.springcloud.cn/ 4.2 基于源代码方式启动Nacos 基于Nacos的最新Master代码，本地IDEA设置环境变量-Dnacos.standalone=true，启动Nacos，如下所示:\n2.打开浏览器访问 http://localhost:8848/nacos/index.html,输入用户名和密码(均为nacos)登录。 4.3 启动同步服务测试 4.3.1 搭建同步服务  示例工程如spring-cloud-nacos-eureka-proxy-example所示,在一个Eureka Server中引入如下的pom依赖:  \u0026amp;lt;dependencies\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; …","date":1573365600,"description":"本文从简单落地的角度说明，如何平滑将注册中心从Eureka迁移到Nacos？","dir":"blog/eureka-sync-nacos/","fuzzywordcount":2600,"kind":"page","lang":"zh","lastmod":1573365600,"objectID":"c36a5e6287ae36622584007a107339e1","permalink":"/blog/eureka-sync-nacos/","publishdate":"2019-11-10T14:00:00+08:00","readingtime":6,"relpermalink":"/blog/eureka-sync-nacos/","summary":"1.背景 Nacos与Eureka相比，Nacos的优点非常明显，当然首选Nacos作为注册中心。本文主要介绍如何从Eureka无缝平滑迁移到","tags":["Nacos"],"title":"如何平滑将注册中心从Eureka迁移到Nacos？","type":"blog","url":"/blog/eureka-sync-nacos/","wordcount":2581},{"author":"谭明智","categories":"中台","content":" 背景 今年参加了云栖大会，作为中台的践行者，我也更关注中台架构实施的行业状况，学习了其他公司中台的思想和经验。云栖大会上，我和做中台实践的同学，以及在阿里做中台的朋友进行了深入的交流和探讨，对做中台过程中遇到的比较纠结的问题进行了思考和总结。\n在探讨中台哪些让人纠结不定烦心事之前，我们依然要谈谈我们为什么要做中台（注：本文中台局限于企业 IT 架构的中台，非广义上的中台），做中台到底给我带来哪些好处，想不清楚这些就去深入到中台的细节里也无意义。\n中台概念这几年特别火，就像 90 年代不做 ERP 是等死一样，现在做不做中台也好像能定企业生死一样，弄得大家都在搞中台。但是不是所有的企业都适合做中台，只有符合以下条件的企业，才有实施中台的必要，切莫乱搞。\n所以，如果您是创业团队，或者业务线比较单一，建议不要盲目尝试中台架构，否则将拖累你业务发展的速度 。另外，我们也要清晰的知道实施中台的目的，以及中台会给企业带来的价值，没有实际利益的推动中台就很难落地，或者有形而无神。\n明确了中台的应用场景和价值体现，我们开始实施中台架构的落地。我从今年上半年开始推动中台这件事差不多有几个月的时间，在这个过程中也是摸着石头过河，虽然有很多中台的理论知识可以学习，但是实际的过程中发现，中台的落地是一件非常难的事情，它没有标准，认识也不统一，在一些关键环节存在不少分歧。\n正好此次在云栖大会约了几个实践中台的朋友进行了深入的探讨，把讨论的内容进行总结，希望中台的建设少一些纠结，多一分信心。\n中台定义：思想 VS 工具 什么是中台？每个人可能有不同的理解，行业里也没有严格的定义，但我更认同其中一个说法就是：中台是企业级能力复用的平台。\n如何来解释这句话呢？\n既然核心是能力复用，业务流派认为中台其实是一套思想，只要能够实现能力的复用，满足降本增效的企业目标，采取的所有措施，和一切可复用的能力都是中台的范畴，所以中台是一种组织方式。\n而技术流派的人则认为，既然是能力复用的平台，就一定要有支撑复用的工具，就必须定义一套技术规范来支持复用，中台一定要有基础平台来支撑的。\n中台首先要统一思想，围绕能力的复用进行组织管理，将能力组件化，如下图最底层部分；同时，中台之上我们要构建能快速落地的技术平台（如图中 OECP 部分），通过 Low code 的平台能力，实现组件的组装和流程的设计，快速的构建应用。\n技术平台是业务无关性的，但业务中台一定是业务相关性的，只要把业务和技术有机的组合起来，把企业的能力沉淀并复用起来，这就有了中台的基础。 复用粒度：粗粒度 VS 细粒度 复用是中台建设的核心，是一切的基础，没有复用的意识导向，中台就变成了自娱自乐的游戏。也许很多人会说，没有中台之前复用无处不在啊，我们写程序复用代码，做方案复用案例，为什么一定要建设中台呢？\n首先，再次重申下中台的复用范围是“企业级”，它既不局限于技术同学内的程序复用，也不局限于一个团队内部的复用，而是站在企业最高的视角，作用于整个企业的 IT 架构；其次是“能力的复用”，能力的范围更加宽泛。\n和阿里的朋友谈到复用时，我们也提到了复用的级别，像阿里云其实就是在基础设施这个级别上的复用。我自己把复用的级别抽象成下图所示的 5 层。 级别越低，粒度越小，复用的范围越广，但价值体现较低；级别越高，粒度越大，复用的价值越高，但复用范围也比较局限。\n所以站在业务和价值角度上，都是先从最高的层次上去复用。只有上层无法实现复用，我们才会逐步向下层去寻找。但是有时候站在技术角度，我们习惯在低层次上去复用，因为这里最接近自己的工作，粒度越小，技术上越可控。但不论怎样只要我们能把这些能力很好的组织管理起来并实现复用，就是中台的思维。\n具体到中台落地的 IT 架构，微服务基础架构是目前最流行的方式，因为单纯程序代码的复用价值有限，而传统单体应用的复用又极其的不灵活，而基于微服务架构的业务组件的复用则处在中间层级，灵活性和复用度比较平衡。\n组件复用的核心思想是领域驱动设计（DDD)，而我认为 DDD 最大难点是粒度的控制，粒度太粗不灵活、复用性差，粒度太细虽然复用性好，但耦合较大，运维成本较高。\nGartner 在研究报告里提出了宏服务、小服务和微服务的粒度划分：\n 宏服务——一种传统的 Web 服务，支持将功能封装于单体应用内。宏服务不支持独立部署或扩展， 它们只能部署为单体应用的一部分，而且它们不需要微服务基础架构。\n 小服务——就服务粒度范围而言，小服务是一种粗粒度、松散耦合、支持独立部署的应用组件。小服务需要微服务基础架构。\n 微服务——微服务处于粒度范围的远端，是一种可独立部署的组件，能够支持单个应用功能的实施。微服务可直接部署到微服务运行时环境中，也往往具备专用数据存储区。微服务需要微服务基础架构。\n  我本人非常喜欢 Gartner 的划分方式，基于这三种服务的粒度，我也谈谈我对粒度把握的一些思路。\n如果我们想对已存在系统的能力进行复用，可以采用宏服务模式进行，宏服务的模式适合做系统的集成和治理。我们对于新的业务和项目，刚开始建议采用小服务的方式进行业务领域的拆分，不建议拆分的过细，这个小服务能满足该需求的基本抽象即可。从适中的粒度开始，服务的粒度一定是业务推进的过程中不断演化的，创新业务推动服务的粒度向更细的粒度裂变，而业务成熟稳定后，又推动服务向粗粒度方向聚合。\n流程支持：服务编排 VS SOP 实践证明，业务能力输出的内容主要是核心业务数据和业务流程。而在我上面定义的复用级别上，业务流程的复用处在 LV4，也是比较高阶的复用能力。\n云栖大会的朋友聚会上，我一个实践中台的同学谈到中台服务如何更加灵活的支撑前台时谈到服务的编排。他们的做法是给前台同事提供了一套服务编排的工具，然后发布一系列的原子性的服务，由各前台团队按照自己流程去编排适合自己的逻辑流程。\n我不反对服务编排，而且在 SOA 和微服务的架构下，服务编排是必不可少的能力。但是我不认可给前台提供编排工具，而中台只提供原子性服务。因为我们在中台的建设中，一直提及的是中台一定是业务相关性的，中台输出的不仅仅是工具，更要深入到具体的业务场景中，提供业务流程的最佳实践。\n阿里的朋友在讨论这个问题是提到了 SOP（Standard Operation Procedure）的概念，他认为最好的做法是提供一套标准化的流程 + 预留可动态注入的扩展点的方式来对前台提供。\n比如淘宝和天猫在业务上可以共享一套 SOP，在这套 SOP 的扩展点上各自注入自己不同的规则，从而满足自己的需求。从中台的复用范围来看，我特别认同这种方式，因为中台只有提供 SOP，才是真正的实现业务流程这种高阶的复用（就像国外 ERP 宣扬的那样，你购买的不只是一套系统，还有企业管理到最佳实践）。\n当然如果要做到 SOP 的定义，中台团队必须有既精通业务又熟悉技术的人，我们俗称“业务架构师”，不过水平高的人实在可遇不可求啊。从这点我也理解把工具开放给前台自己做服务编排的同学了。\n虽然我一直在强调中台要深入业务，要提炼 SOP，但中台又不能过度参与业务，不能因为中台掣肘了业务的敏捷性。中台提供的能力要具有灵活性和可定制性，便于业务方根据规范自主完成，减少沟通成 …","date":1572328800,"description":"今年参加了云栖大会，作为中台的践行者，我也更关注中台架构实施的行业状况，学习了其他公司中台的思想和经验。云栖大会上，我和做中台实践的同学，以及在阿里做中台的朋友进行了深入的交流和探讨，对做中台过程中遇到的比较纠结的问题进行了思考和总结","dir":"blog/zt/2/","fuzzywordcount":4200,"kind":"page","lang":"zh","lastmod":1572328800,"objectID":"504bb5ef5e702835c28ce00f98070818","permalink":"/blog/zt/2/","publishdate":"2019-10-29T14:00:00+08:00","readingtime":9,"relpermalink":"/blog/zt/2/","summary":"背景 今年参加了云栖大会，作为中台的践行者，我也更关注中台架构实施的行业状况，学习了其他公司中台的思想和经验。云栖大会上，我和做中台实践的同学","tags":["业务中台"],"title":"向左还是向右？聊聊中台建设中的那些纠结事","type":"blog","url":"/blog/zt/2/","wordcount":4194},{"author":"许进","categories":"中间件","content":" 中间件列表 ","date":1571986800,"description":"本文用Xmind梳理一下中国互联网20多年造的中间件轮子","dir":"blog/mw/1/","fuzzywordcount":100,"kind":"page","lang":"zh","lastmod":1571986800,"objectID":"fceab42dd4fdbc63f384eba396a8157d","permalink":"/blog/mw/1/","publishdate":"2019-10-25T15:00:00+08:00","readingtime":1,"relpermalink":"/blog/mw/1/","summary":"中间件列表","tags":["中间件"],"title":"中国互联网20多年中间件合集","type":"blog","url":"/blog/mw/1/","wordcount":5},{"author":"许进","categories":"中台","content":" 前言 从2018年开始，“中台”成为风靡IT技术圈的热词，每个人对中台的理解就像一千个观众眼中有一千个哈姆雷特一样。本文将从可落地的角度，分享如何打造业务中台发动机，帮助大家快速落地业务中台。仁者见仁,智者见智，欢迎大家拍砖。\n业务中台发动机的目标很简单，就是打造一个光环(Halo),给普通业务应用带上去，变为带有光环的中台应用，形成可复用的业务资产，快速响应业务，进行赋能。\n1. 什么是业务中台 业务中台其实就是按照业务域划分，把业务代码做成可复用的业务资产组件库，快速响应业务。\n1.1 哪些公司适合做业务中台 业务中台搭建最终是为了形成可复用的业务资产，形成业务组件库。如果公司的业务线单一(业务形态单一)，产品单一，对接的渠道单一，不建议做业务中台。可以按业务域划分，做服务化。\n国内一线或二线等互联网公司，中大型企业，或者业务复杂，多产品线，多业务形态等公司，适合做业务中台。\n1.2 建设业务中台原则  业务与业务隔离 各业务线和业务形态，必须隔离，不能相互影响，形成可自治的业务空间，可以通过包隔离或应用隔离。\n 业务与平台隔离 某个业务或业务形态需要与平台隔离，当某个业务停滞，或者由于效益不好砍掉，或者业务的演变开发不能影响整个平台的稳定性。比如在线教育平台，不能让某个业务线生命周期，影响整个在线教育平台的稳定性。\n 业务资产可视化 业务中台建设，必须业务资产可式化，业务域可视化，应用内部流程可视化，扩展点和插件可视化，全链路业务身份可视化，代码能力即中台能力。说直白一点就是，业务代码可视化，帮助你了解有多少业务资产，有多少业务线，有多少中台能力，有多少域服务，有多少域能力，哪些可以复用，编排，拖拽下发快速响应业务需求。\n 全局业务身份 平台需要能有按“业务身份”进行业务与业务之间逻辑隔离的能力\n  1.3 打造业务中台条件 业务中台的打造需要天时，地利，人和。\n 天时就是公司适合做业务中台,目前的业务应用无法满足快速响应业务方的需求(换句话就是说需要重构,不然很难做业务中台)，\n 地利就是公司组织架构，自上而下支持。\n 人和是有业务架构+中台应用架构的人才，从而组建中台团队。没有业务架构+中台应用架构合适的人才，那业务域怎么划分，业务模型是什么样的，比如商品模型怎么设计(SPU和SKU的怎么设计满足扩展需求，更加合理。业务域划分清楚之后，架构分层设计，各种防腐设计，以及架构演变进化，通过应用架构将业务架构和技术架构无缝衔接，从而打造出中台应用发动机。\n   打造业务中台，必须先打造业务中台发动机。\n 2.为什么要打造业务中台发动机 一辆好的汽车，或者好的航空母舰都具有一个非常强大的发动机，只有给业务应用装上中台发动机才能变为中台应用，逐渐在架构治理和代码防腐之中演变为真正意义的业务中台。 业务中台的建设落地除了需要科学的方法论之外，还需要将方法论落地变为中台应用框架和配套的基础设施，从而规范业务中台应用的创建规范，中台应用架构规范，中台应用演变进化规范。\n3. 如何打造业务中台发动机 打造业务中台发动机，需要考虑以下几点:\n 中台框架，必须是应用框架+技术架构和中间，需要由具备应用架构和基础架构的人参与打造,让中台开发工程师专注于业务组件库开发。\n 应用框架必须整合领域驱动设计，开发出可落地的工具支撑(代码生成器或IDE插件)。只有领域驱动才可以实现业务与业务之间隔离。只有工具支撑才能保证整个业务中台建设的质量和交付的治理，从而衡量整个中台建设的成熟度。\n 业务中台发动机需包含中台可视化管控，进行全方位的可视化视角管控。\n  4.中台应用框架 4.1 中台框架设计 Halo(内部代号，中文含义:光环)的主要设计思想是流程组合节点,节点调用域服务,域服务可以调用若干域能力,域能力下若干个业务扩展。具体如下:\n 可编排场景:一切业务请求皆为命令，命令执行器中启动业务流程，业务流程组合节点,节点调用域服务,域服务可以调用若干域能力。流程，节点，域服务，域能力都可以出现多个业务扩展，由业务身份路由或决策出业务身份执行。\n 不编排场景:一切业务请求皆为命令,命令执行器中，调用域服务，域服务调用域能力。域服务，域能力都可以出现多个业务扩展，由业务身份路由或决策出业务身份执行。\n 整个业务活动链路统一业务身份：业务请求按照“业务身份”进行路由处理，从而路由到对应的DDD领域模型中，从而实现业务与业务的隔离，各业务线之间的隔离。\n 管理域与运行域分离： 业务逻辑不能依靠运行期动态计算，当业务身份进行冲突时，可以通过类似的策略中心进行决策，返回对应的业务身份处理。\n  Halo框架，未来将根据实际情况实现业务包与平台分离的插件化架构, 所谓插件化架构，也就是业务中台提供插件包注册与发现机制，业务方根据扩展点开发对应的插件包注册到业务中台平台。通过容器化加载和实现，最终实现业务和平台的隔离。\n4.2 DDD应用于中台框架 根据领域驱动设计思想，自定义注解 @Entity(实体)，@Factory(工厂), @DomainService(领域服务), @ValueObject(值对象)，@DomainRepository(资源库)，@DomainAbility(域能力) 等进行战术设计，落地DDD，实现业务与业务隔离。\n4.3 扩展点思想引入 Halo框架引入扩展点设计思想，所谓扩展点就是接口，扩展就是接口的多种实现，可以理解为基于注解的动态策略模式，而Halo框架扩展点的执行,需要根据业务身份路由到对应的扩展点实现.因此需要提取业务身份。\n4.4 应用内部流程编排引入 当中台应用中没有流程编排的时候，会出现以下问题：\n 代码复用方式千奇百怪，无统一标准。\n 模块划分无章可循。\n 应用日趋复杂\n 流程变更过程冗繁。\n   因为没有流程编排会出现如上的问题，因此组件化需求产生，将代码形成可复用的代码资产。因此Halo框架基于注解的方式定义的一套组件的开发方式和复用方式。由于内容比较多这里将不再展开。\n 最终实现的组件化需求,形成一套简单的复用标准，一个简单的模块划分标准。从而多么复杂多变的业务都可轻松应对，使代码更加轻量、敏捷、易用。\n5.中台代码生成器 中台代码生成器的目标就是快速创建中台应用，解决开发效率，规范中台研发。其中内置中台应用框架的分层设计和中台应用基础设施等。 中台代码代码生成器分为服务端和客户端。\n 服务端主要根据前端请求提交的参数，代码生成器引擎去生成代码。\n 客户端主要分为网页端和IDEA插件端，用于跟用户交互。\n  6. 中台IDEA插件 中台IDEA插件(内部代号:Halo Tools)主要有中台应用向导式创建功能，右键创建13个Java类功能，以及行标记和中台可视化联动功能，以及插件设置功能。\n6.1 向导式创建功能 根据向导方式，快速创建中台应用。 6.2 @Domain行标记修改 Halo框架所创建的应用需要管中台可视化纳管，因此当应用启动的时候会判断当前应用是否属于某个域，不属于某个域将停止启动，HaloTools提供一个快速修改编辑的功能。如下图所示:\n6.4 Halo Tools增强右键 Halo Tools提供右键增强功能，帮助开发快速创建常用的Java类，提高 …","date":1571724000,"description":"从2018年开始，“中台”成为风靡IT技术圈的热词，每个人对中台的理解就像一千个观众眼中有一千个哈姆雷特一样。本文将从可落地的角度，分享如何打造业务中台发动机。","dir":"blog/zt/1/","fuzzywordcount":3200,"kind":"page","lang":"zh","lastmod":1571724000,"objectID":"7050335869c6ed21ec6402fde79893f0","permalink":"/blog/zt/1/","publishdate":"2019-10-22T14:00:00+08:00","readingtime":7,"relpermalink":"/blog/zt/1/","summary":"前言 从2018年开始，“中台”成为风靡IT技术圈的热词，每个人对中台的理解就像一千个观众眼中有一千个哈姆雷特一样。本文将从可落地的角度，分享","tags":["业务中台"],"title":"如何打造业务中台发动机?","type":"blog","url":"/blog/zt/1/","wordcount":3198},{"author":"许进","categories":"Halo Tools","content":" 1.行标记 1.1 行标记概述 IDEA源码编辑代码区域，可以编辑代码。大家肯定看到行上面有一些图标，其实我们也可以定义自己的行标记结合自己的需要弹窗修改代码或进行导航。\nHalo框架所创建的应用需要管中台可视化纳管，因此当应用启动的时候会判断当前应用是否属于某个域，不属于某个域将停止启动，HaloTools提供一个快速修改编辑的功能。@Domain注解行标记修改,如下图所示:\n1.2 开发一个行标记  1.在plugin.xml中添加行标记扩展配置,如下代码所示：  \u0026amp;lt;extensions defaultExtensionNs=\u0026amp;quot;com.intellij\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;!--如下所示添加行标记扩展 --\u0026amp;gt; \u0026amp;lt;codeInsight.lineMarkerProvider language=\u0026amp;quot;JAVA\u0026amp;quot; implementationClass=\u0026amp;quot;org.xujin.idea.right.linemarker.HaloLineMarker\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;/extensions\u0026amp;gt;   2.创建HaloLineMarker.java，代码如下所示:  public class HaloLineMarker implements LineMarkerProvider { @Nullable @Override public LineMarkerInfo getLineMarkerInfo(@NotNull PsiElement psiElement) { LineMarkerInfo lineMarkerInfo= null; try { lineMarkerInfo = null; String anno=\u0026amp;quot;org.springframework.boot.autoconfigure.SpringBootApplication\u0026amp;quot;; if(!judgeHaveAnnotation(psiElement,anno)){ return lineMarkerInfo; } PsiClassImpl field = ((PsiClassImpl) psiElement); PsiAnnotation psiAnnotation = field.getAnnotation(anno); lineMarkerInfo = new LineMarkerInfo\u0026amp;lt;\u0026amp;gt;(psiAnnotation, psiAnnotation.getTextRange(), IconLoader.findIcon(\u0026amp;quot;/icons/right/HaloBasic.png\u0026amp;quot;), new FunctionTooltip(\u0026amp;quot;快速导航\u0026amp;quot;), new AppMgmtNavigationHandler(),// ➊ GutterIconRenderer.Alignment.LEFT); } catch (Exception e) { e.printStackTrace(); // ➋ } return lineMarkerInfo; } @Override public void collectSlowLineMarkers(@NotNull List\u0026amp;lt;PsiElement\u0026amp;gt; list, @NotNull Collection\u0026amp;lt;LineMarkerInfo\u0026amp;gt; collection) { } private boolean judgeHaveAnnotation(@NotNull PsiElement psiElement, String anno) { if (psiElement instanceof PsiClass) { PsiClassImpl field = ((PsiClassImpl) psiElement); PsiAnnotation psiAnnotation = field.getAnnotation(anno); if (null != psiAnnotation) { return true; } return false; } return false; } }  ➊ 添加行标记点击之后处理的Handler。\n➋ ((PsiClassImpl) psiElement)会出现异常，因此进行try-catch处理,代码仅做案例演示\n 上述代码，仅作为代码案例展示。离实际项目还有优化空间，本案例代码:https://github.com/SoftwareKing/idea-study/tree/master/idea-study-02。\n  3.启动IDEA插件模拟器debug，可以看到如下图所示，行标记处理成功。  ","date":1571389200,"description":"IDEA源码编辑代码区域，可以编辑代码。其实我们也可以定义自己的行标记结合自己的需要弹窗修改代码或进行导航","dir":"blog/idea/line-marker-2/","fuzzywordcount":700,"kind":"page","lang":"zh","lastmod":1571389200,"objectID":"a5ba9d91c5c620c65b7b99950f6e0beb","permalink":"/blog/idea/line-marker-2/","publishdate":"2019-10-18T17:00:00+08:00","readingtime":2,"relpermalink":"/blog/idea/line-marker-2/","summary":"1.行标记 1.1 行标记概述 IDEA源码编辑代码区域，可以编辑代码。大家肯定看到行上面有一些图标，其实我们也可以定义自己的行标记结合自己的需要弹窗","tags":["Halo Tools"],"title":"IDEA插件开发-自定义行标记","type":"blog","url":"/blog/idea/line-marker-2/","wordcount":624},{"author":null,"categories":null,"content":" 1. Halo Check概述 Halo Check基于Git Hook+JGit+CheckStyle+PMD对代码增量diff Check是否满足Halo Style。在代码Git Commit提交的时候进行检查。分为客户端和Gitlab服务端Check。\n 支持应用白名单过滤，在白名单里面的应用，当进行Git Commit时候不进行check 一个应用可以对应一个checkstyle和pmd检测文件 对check不过的git提交人，进行次数评级  2.Halo Check模块    模块 说明     halo-check-core  基于JGit获取增量的diff代码片段，非单个Java文件。   halo-checkstyle 基于Checkstyle 定制Halo CheckStyle,变成可执行Jar进行Check   halo-pmd 对阿里P3c pmd进行增强，变成可执行Jar   halo-maven-githook Halo Check的Mave插件n安装器，埋在Halo框架顶级父Pom中传递    ","date":1571356800,"description":"","dir":"projects/halo-check/overview/","fuzzywordcount":400,"kind":"page","lang":"zh","lastmod":1571356800,"objectID":"707cb84d0f0088b08d457559ab12eecf","permalink":"/projects/halo-check/overview/","publishdate":"2019-10-18T00:00:00Z","readingtime":1,"relpermalink":"/projects/halo-check/overview/","summary":"1. Halo Check概述 Halo Check基于Git Hook+JGit+CheckStyle+PMD对代码增量diff Check是否满足Halo Styl","tags":null,"title":"Halo Check 介绍","type":"projects","url":"/projects/halo-check/overview/","wordcount":354},{"author":null,"categories":null,"content":" 1. Halo Plugin概述 Halo Plugin是Halo框架量身打造的maven插件或Gradle插件。\n2.Halo Plugin 2.1 Gradle插件 halo-reference-plugin是专为Halo框架文档的编写定制的Gradle插件.通过此插件可以生成类似Spring的文档，示例如下图所示. gralde引入依赖如下所示:\ndependencies { //Provides additional optional and provided dependency configurations for Gradle along with Maven POM generation support classpath(\u0026amp;quot;org.springframework.build.gradle:propdeps-plugin:0.0.7\u0026amp;quot;) classpath(\u0026amp;quot;org.asciidoctor:asciidoctor-gradle-plugin:1.5.0\u0026amp;quot;) classpath(\u0026amp;quot;org.xujin.gradleplugin:halo-reference-plugin:0.0.2-SNAPSHOT\u0026amp;quot;) }  ","date":1571356800,"description":"","dir":"projects/halo-plugin/overview/","fuzzywordcount":200,"kind":"page","lang":"zh","lastmod":1571356800,"objectID":"b056b0cd31ad7449c729a8fde799b758","permalink":"/projects/halo-plugin/overview/","publishdate":"2019-10-18T00:00:00Z","readingtime":1,"relpermalink":"/projects/halo-plugin/overview/","summary":"1. Halo Plugin概述 Halo Plugin是Halo框架量身打造的maven插件或Gradle插件。 2.Halo Plugin 2.1 Gradle插件 halo-referenc","tags":null,"title":"Halo Plugin 介绍","type":"projects","url":"/projects/halo-plugin/overview/","wordcount":169},{"author":"许进","categories":"中间件","content":" 1.开关中间件 1.1 Switch概述 switch提供统一的方式来定义开关、统一的控制台和api来对开关进行查询和操控。Switch定义的开关包含丰富的可读性属性，为开关信息的维护和传承提供便利。\n1.2 Switch使用的业务场景 在分布式系统中为什么要使用开关？例如双十一电商平台需要做促销活动，此时订单量暴增，在下单环节，可能需要调用A、B、C三个接口来完成，但是其实A和B是必须的，C只是附加的功能（例如在下单的时候获取用户常用地址，或者发个推送消息之类的），可有可无，在平时系统没有压力，在容量充足的情况下，调用下没问题，但是在特殊节日的大促环节，系统已经满负荷了，这时候其实完全可以不去调用C接口，怎么实现这个呢？改代码重新发布？no，这样不太现实，于是开关诞生了，开发人员只要简单执行一下命令或者点一下页面，就可以关掉对于C接口的调用，在请求高峰过去之后，再把开关恢复回去即可。类似的使用场景还有A/B Test、灰度发布和数据的不停服切换等。\n早期这样的业务开关都是由各个部门自行实现和管理。随着业务开关的数量的增多，大量的业务开关信息都分布在不同的系统中，甚至代码中，造成运维的成本越来越高，当开关不使用之后，无法进行统一的下线处理。 因此需要开发一套统一的标准和规范的业务开关管理的Switch平台。还有其它业务使用场景，如下所示:\n 业务降级中需要对代码中的static值的修改 应用不同版本的兼容 不用时间走不同的优惠服务 采用业务开关的方式，通过修改程序中的static值实现业务逻辑的切换。 业务复杂，从面向对象到面向开关编程   Q:是否需要支持跨应用的开关推送,某些业务场景需要跨应用推送\nA:目前阿里的开关不支持跨应用开关的推送，某个业务场景需要好几个应用一起打开开关。\n 2.2 Switch的分类: 我们可以将开关分为三大类，分别是功能开关、降级开关、灰度开关：\n 功能开关：针对某一个功能是否打开，例如在订单下单的时候需要获取下单用户的历史换绑手机号信息，但是由于B系统只是提供了接口定义，实际业务还未开发完成，A系统可以先提前开发并上线，待B系统上线之后，A系统将该功能开关打开。\n 降级开关:典型的应用场景是电商做促销的时候，比如双十一电商做促销，用户下单的时候获取用户历史常用地址，因为双十一系统已经达到负荷，为了系统性能，将该业务逻辑降级。或者A系统调用B系统，由于B系统整体宕机，为了不影响A系统继续运行，可以手动将B系统降级等。\n 灰度开关:针对某一功能做灰度，例如我们需要针对刷单用户在下单过程中做拦截，为此我们在下单阶段做了一套黑白名单处理，但是我们也无法知晓该套黑白名单的正确率多少，为了避免造成误拦，我们需要对该功能做灰度采样，以便及时调整我们的黑白名单逻辑。通常的灰度策略为 1% 灰度，10%灰度，30%灰度，50%。。。\n  2.3 分布式Switch的需求 开关的核心需求主要有以下几点: 1. 支持开关的分布式化管理\n 开关统一管理，发布、更新等操作只需在管控平台上执行一次变更，整个集群生效。\n  当开关值发生变更，订阅该开关的客户端会自动感知发现变更，进而应用内部更新值。\n  支持单台服务器的开关变更   具有容灾机制，保证服务的HA（高可用）\n  管控平台HA \u0026amp;gt; 部署两个，通过Ngnix或LVS保证高可用\n  服务集群的高可用,当集群中的一台server不可用了，client发现后可以自动切换到其他server上进行访问 \u0026amp;gt; 基于Apollo或者Nacos实现   客户端具备容灾机制，当开关中心完全不可用，可以在客户端对开关进行操作。 \u0026amp;gt; 配置中心或管控平台Http接口实现对客户端的操作\n   2.4 Switch竞品分析 目前开关中间件市面上开源可用的产品为0，下面对竞品做简单介绍对比，如下表所示:\n   开关 数据一致性 说明 备注     点我达 基于Zk 依赖ZK，有管控平台 点我达开关设计   阿里 基于Diamond（即目前开源的Nacos中的Config) 依赖配置中心Diamond，有管控平台，支持Http API变更开关     2.5 Switch具备的功能 通过对目前市面上开关的竞品分析，下面的功能将是Switch的RoadMap需要实现的功能\n支持不同类型的配置项和业务开关的基础推送功能 支持多种灵活的推送方式 支持Nacos和Apollo 线上控制台可以直接推送到内存，正常情况下使用开关控制台推送开关值到内存。 支持集群推送和单机推送 线上控制台持久化推送，借助配置中心Naocos或Apollo持久化业务开关。即使在应用重启了，也会生效。 高可用，如果开关控制台出现异常或挂掉，可以直接通过Nacos或者Apollo自身的控制台来编辑开关值。 Http API推送。若配置中心Nacos或Apollo推送延迟高或者出现异常挂掉。可直接通过Http API接口来才操作开关。 Switch保证业务开关推送的正取性，实时性的同时，提供业务开关的监控功能， 能监控集群开关状态，降低开关不一致带来的风险。若有机器的开关值不一致，或者某台机器已经下线，则会提醒相应的操作人员及时调整开关值，保持集群状态一致。   3.Switch设计 Switch的设计将会从Client，管控平台，适配多种配置中心，高可用等几个角度来设计。做到以下几点\n Switch尽可能使用简单,switch框架提供非常简单的使用方式，对应用方原来的使用侵入小\n基于配置中心Nacos或Apollo实现推送，为了保证更可靠需要支持Http API的推送方式\n 3.1 Switch的方案设计 Switch总体架构，如下图所示:\n a. Switch Admin-管理控制台\n管理控制台主要用于对分组、应用及开关进行操作，核心功能就是对开关进行控制，包括分布式和单机操作模式  b. Apollo或Nacos\n   分布式开关统一注册中心，主要提供变更通知服务，客户端通过订阅开关节点，实时获取开关变更信息，从而同步更新到本地内存 * c. 开关client\n 基于spi机制加载应用内开关组件，并注册到配置中心，并基于netty实现tcp及http通信交互，方便本地及管理控制台调用。 3.2 功能模块设计 Switch的功能模块设计图，如下所示:\n   模块 说明 备注     switch 父模块    switch-core 开关的核心模块 核心逻辑   switch-adpater 开关底层抽象适配    switch-admin 开关管控平台 管控平台   switch-adpater-apollo 开关管控平台适配阿波罗 通过OpenAPI下发开关   switch-adpater-nacos 开关管控平台适配阿波罗 通过OpenAPI下发开关   switch-client 开关Client的父模块    switch-client-adapter 开关Client的适配器接口    switch-client-adapter-apollo 开关客户端Apollo Starter提供的二方包    switch-client-adapter-nacos  …","date":1571313600,"description":"本文主要介绍开关中间件的设计，switch提供统一的方式来定义开关、统一的控制台和api来对开关进行查询和操控。Switch定义的开关包含丰富的可读性属性，为开关信息的维护和传承提供便利","dir":"blog/mw/switch1/","fuzzywordcount":3800,"kind":"page","lang":"zh","lastmod":1571313600,"objectID":"7acaa3e2553370dac89547fac4e75148","permalink":"/blog/mw/switch1/","publishdate":"2019-10-17T20:00:00+08:00","readingtime":8,"relpermalink":"/blog/mw/switch1/","summary":"1.开关中间件 1.1 Switch概述 switch提供统一的方式来定义开关、统一的控制台和api来对开关进行查询和操控。Switch定义的开关包含","tags":["Switch","中间件"],"title":"Switch-开关中间件设计","type":"blog","url":"/blog/mw/switch1/","wordcount":3749},{"author":null,"categories":null,"content":" 1. Halo Admin Halo Framework对应的中台可视化管控平台，主要包括业务中台域管理，应用管理,业务流程可视化，业务身份管理等\n","date":1570971600,"description":"","dir":"projects/halo-admin/overview/","fuzzywordcount":100,"kind":"page","lang":"zh","lastmod":1570971600,"objectID":"7421a8de03ed36a011b6e9c8756d75cf","permalink":"/projects/halo-admin/overview/","publishdate":"2019-10-13T21:00:00+08:00","readingtime":1,"relpermalink":"/projects/halo-admin/overview/","summary":"1. Halo Admin Halo Framework对应的中台可视化管控平台，主要包括业务中台域管理，应用管理,业务流程可视化，业务身份管理等","tags":null,"title":"Halo Admin概述","type":"projects","url":"/projects/halo-admin/overview/","wordcount":58},{"author":null,"categories":null,"content":" 1. 代码生成器 1.1 什么是代码生成器 早起进行软件工程开发，用文本编辑器去开发写代码，后来为了加快开发效率，出现一系列IDE（开发集成开发工具),比如Eclipse,IDEA等。创建Maven或者Gradle工程都是通过IDE去创建，但是有些重复的工作，比如单表的CRUD操作，或者重复性劳动的配置，包括Maven或者Gradle的配置。\n2. 代码生成器设计 如下图所示，代码生成器的生成的工程，由元数据+模板(工程模板或代码模板)组装而成。 * 元数据 * 模板 3.Halo CodeGen Halo Codegen是一个服务端，其中网页版和IDEA插件都是客户端，客户端只是用于跟用户交互，提交数据用于生成Halo Project\n","date":1570885200,"description":"","dir":"projects/halo-codegen/overview/","fuzzywordcount":300,"kind":"page","lang":"zh","lastmod":1570885200,"objectID":"7334f471720e8a2b2e95a85ca4fbf131","permalink":"/projects/halo-codegen/overview/","publishdate":"2019-10-12T21:00:00+08:00","readingtime":1,"relpermalink":"/projects/halo-codegen/overview/","summary":"1. 代码生成器 1.1 什么是代码生成器 早起进行软件工程开发，用文本编辑器去开发写代码，后来为了加快开发效率，出现一系列IDE（开发集成开发工具),比","tags":null,"title":"Halo Codegen概述","type":"projects","url":"/projects/halo-codegen/overview/","wordcount":282},{"author":"许进","categories":"Halo Tools","content":" 1. @Domain行标记修改 Halo框架所创建的应用需要管中台可视化纳管，因此当应用启动的时候会判断当前应用是否属于某个域，不属于某个域将停止启动，HaloTools提供一个快速修改编辑的功能。如下图所示:  如上图所示，可以成功进行行标记代码修改，但是会出现报错信息,下面将对报错信息进行分析Fix。\n 2.报错分析 java.lang.Throwable: Assertion failed: Write access is allowed inside write-action only (see com.intellij.openapi.application.Application.runWriteAction()) at com.intellij.openapi.diagnostic.Logger.assertTrue(Logger.java:180) at com.intellij.openapi.application.impl.ApplicationImpl.assertWriteAccessAllowed(ApplicationImpl.java:1344) at   大致意思是写的权限只能在Application.runWriteAction()里面是允许的 查询官网资料解释如下图所示:    IDEA行标记修改用到了写文件操作，因此需要在线程中操作，不然会出现文章开头出现的错误。\n 3. Bug Fix 定位到出错代码，如下所示:\nprocessor.executeCommand(project, new DocumentReplace(document, startOffset, endOffset, domain), \u0026amp;quot;\u0026amp;quot;, document)  将上述代码放入写操作中，修改如下所示:\n@Override public void navigate(MouseEvent mouseEvent, PsiElement psiElement) { Application applicationManager = ApplicationManager.getApplication(); applicationManager.runWriteAction(() -\u0026amp;gt; ➊ processor.executeCommand(project, new DocumentReplace(document, startOffset, endOffset, domain), \u0026amp;quot;\u0026amp;quot;, document) ➋ ); DomainModelContext.clearAllSet(); }  ➊ 在applicationManager.runWriteAction线程中开启写操作\n➋ 进行行标记代码替换操作\n","date":1570611600,"description":"IDEA插件运行报错:Write access is allowed inside write-action only, 对报错进行分析进行Fix。","dir":"blog/idea/line-marker-1/","fuzzywordcount":500,"kind":"page","lang":"zh","lastmod":1570611600,"objectID":"6f83fb0028e9348818c35a0b470bcd58","permalink":"/blog/idea/line-marker-1/","publishdate":"2019-10-09T17:00:00+08:00","readingtime":1,"relpermalink":"/blog/idea/line-marker-1/","summary":"1. @Domain行标记修改 Halo框架所创建的应用需要管中台可视化纳管，因此当应用启动的时候会判断当前应用是否属于某个域，不属于某个域将停止","tags":["Halo Tools"],"title":"IDEA插件运行报错:Write access is allowed inside write-action only","type":"blog","url":"/blog/idea/line-marker-1/","wordcount":400},{"author":"许进","categories":"Spring Boot Admin","content":" 摘要:本文主要讲解如何将Spring Boot Admin与Spring Cloud Alibaba中的spring-cloud-starter-alibaba-nacos-discovery进行整合使用。\n1. 整合概述 通过搭建一个Spring Boot Admin Server，并将其通过spring-cloud-starter-alibaba-nacos-discovery注册到Nacos Server中即可。 源码工程地址为:https://github.com/SoftwareKing/sba-nacos\n 说明本文使用的Spring Boot Admin的版本为2.1.2，Spring Cloud的版本为Greenwich.RELEASE，Spring Cloud Alibaba的版本为0.2.1.RELEASE。至于其它版本，请读者自行适配处理。\n 2. 创建sba-nacos工程 1.创建sba-nacos工程，添加maven依赖如下所示:\n\u0026amp;lt;?xml version=\u0026amp;quot;1.0\u0026amp;quot; encoding=\u0026amp;quot;UTF-8\u0026amp;quot;?\u0026amp;gt; \u0026amp;lt;project xmlns=\u0026amp;quot;http://maven.apache.org/POM/4.0.0\u0026amp;quot; xmlns:xsi=\u0026amp;quot;http://www.w3.org/2001/XMLSchema-instance\u0026amp;quot; xsi:schemaLocation=\u0026amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;modelVersion\u0026amp;gt;4.0.0\u0026amp;lt;/modelVersion\u0026amp;gt; \u0026amp;lt;parent\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-parent\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.1.2.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/parent\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.xujin.moss\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sba-nacos\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;properties\u0026amp;gt; \u0026amp;lt;spring.boot.admin.version\u0026amp;gt;2.1.2\u0026amp;lt;/spring.boot.admin.version\u0026amp;gt; \u0026amp;lt;/properties\u0026amp;gt; \u0026amp;lt;dependencyManagement\u0026amp;gt; \u0026amp;lt;dependencies\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-dependencies\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;Greenwich.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;type\u0026amp;gt;pom\u0026amp;lt;/type\u0026amp;gt; \u0026amp;lt;scope\u0026amp;gt;import\u0026amp;lt;/scope\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-alibaba-dependencies\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;0.2.1.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;type\u0026amp;gt;pom\u0026amp;lt;/type\u0026amp;gt; \u0026amp;lt;scope\u0026amp;gt;import\u0026amp;lt;/scope\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;/dependencies\u0026amp;gt; \u0026amp;lt;/dependencyManagement\u0026amp;gt; \u0026amp;lt;dependencies\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-actuator\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-alibaba-nacos-discovery\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;de.codecentric\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-admin-starter-server\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${spring.boot.admin.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-web\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.jolokia\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;jolokia-core\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;/dependencies\u0026amp;gt; \u0026amp;lt;build\u0026amp;gt; \u0026amp;lt;finalName\u0026amp;gt;sba-nacos\u0026amp;lt;/finalName\u0026amp;gt; \u0026amp;lt;plugins\u0026amp;gt; \u0026amp;lt;plugin\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-maven-plugin\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/plugin\u0026amp;gt; \u0026amp;lt;/plugins\u0026amp;gt; \u0026amp;lt;/build\u0026amp;gt; \u0026amp;lt;/project\u0026amp;gt;   创 …","date":1568635200,"description":"本文主要讲解如何将Spring Boot Admin与Spring Cloud Alibaba中的spring-cloud-starter-alibaba-nacos-discovery进行整合使用","dir":"blog/sba-nacos/","fuzzywordcount":1100,"kind":"page","lang":"zh","lastmod":1568635200,"objectID":"1fee7fce363eec566663cb4106b047af","permalink":"/blog/sba-nacos/","publishdate":"2019-09-16T20:00:00+08:00","readingtime":3,"relpermalink":"/blog/sba-nacos/","summary":"摘要:本文主要讲解如何将Spring Boot Admin与Spring Cloud Alibaba中的spring-cloud-starter-alibaba-","tags":["Spring Boot Admin"],"title":"Spring Boot Admin和Nacos集成","type":"blog","url":"/blog/sba-nacos/","wordcount":1075},{"author":"许进","categories":"Spring Cloud Gateway","content":" 摘要:本文主要介绍了什么是GatewayFilter和GlobalFilter，以及区别和联系。然后介绍如何在Spring Cloud Gateway中自定义使用GatewayFilter和GlobalFilter。\n1. Spring Cloud gateway的Filter Spring Cloud gateway中的Filter从接口实现上分为两种一种是GatewayFilter，另外一种是GlobalFilter。\n1.1 GatewayFilter与GlobalFilter的区别 区别用英语可以总结如下: At a high level global filters are applied to all routes, while a gateway filter will be applied to an individual route(s) \u0026amp;gt;在一个高的角度来看，Global filters会被应用到所有的路由上，而Gateway filter将应用到单个路由上或者一个分组的路由上。在下面的案例中将会进行说明。\n1.2 本文代码地址  https://github.com/SoftwareKing/sc-gateway/tree/master/ch2\n 2. GatewayFilter和GlobalFilter 2.1 GatewayFilter 2.1.1 什么是GatewayFilter Contract for interception-style, chained processing of Web requests that may be used to implement cross-cutting, application-agnostic requirements such as security, timeouts, and others. Specific to a Gateway Copied from WebFilter \u0026amp;gt;GatewayFilter是从WebFilter中Copy过来的，相当于一个Filter过滤器，可以对访问的URL过滤横切处理，应用场景比如超时，安全等。\n从Spring Cloud Gateway的源码中如下所示，可以看出GatewayFilter的使用场景:\n/** * Contract for interception-style, chained processing of Web requests that may * be used to implement cross-cutting, application-agnostic requirements such * as security, timeouts, and others. Specific to a Gateway * * Copied from WebFilter * * @author Rossen Stoyanchev * @since 5.0 */ public interface GatewayFilter extends ShortcutConfigurable { String NAME_KEY = \u0026amp;quot;name\u0026amp;quot;; String VALUE_KEY = \u0026amp;quot;value\u0026amp;quot;; /** * Process the Web request and (optionally) delegate to the next * {@code WebFilter} through the given {@link GatewayFilterChain}. * @param exchange the current server exchange * @param chain provides a way to delegate to the next filter * @return {@code Mono\u0026amp;lt;Void\u0026amp;gt;} to indicate when request processing is complete */ Mono\u0026amp;lt;Void\u0026amp;gt; filter(ServerWebExchange exchange, GatewayFilterChain chain); }   GatewayFilter和GlobalFilter两个接口中定义的方法一样都是Mono filter(ServerWebExchange exchange, GatewayFilterChain chain)，唯一的区别就是GatewayFilter继承了ShortcutConfigurable，GlobalFilter没有任何继承。\n 2.1.2 自定义GatewayFilter(Custom GatewayFilter) 如org.xujin.sc.filter.CustomFilter代码所示，通过自定义GatewayFilter对路由转发的处理时长统计。\npackage org.xujin.sc.filter; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import org.springframework.cloud.gateway.filter.GatewayFilter; import org.springframework.cloud.gateway.filter.GatewayFilterChain; import org.springframework.core.Ordered; import org.springframework.web.server.ServerWebExchange; import reactor.core.publisher.Mono; /** * 统计某个或者某种路由的的处理时长 * @author xujin */ public class CustomFilter implements GatewayFilter, Ordered { private static final Log log = LogFactory.getLog(GatewayFilter.class); private static final String COUNT_Start_TIME = \u0026amp;quot;countStartTime\u0026amp;quot;; @Override public Mono\u0026amp;lt;Void\u0026amp;gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) { exchange.getAttributes().put(COUNT_Start_TIME, System.currentTimeMillis()); return chain.filter(exchange).then( Mono.fromRunnable(() -\u0026amp;gt; { Long startTime = …","date":1568635200,"description":"本文主要介绍了什么是GatewayFilter和GlobalFilter，以及区别和联系。然后介绍如何在Spring Cloud Gateway中自定义使用GatewayFilter和GlobalFilter","dir":"blog/scg-03/","fuzzywordcount":2500,"kind":"page","lang":"zh","lastmod":1568635200,"objectID":"bc295a947c11a9a185c090e0014dc4dd","permalink":"/blog/scg-03/","publishdate":"2019-09-16T20:00:00+08:00","readingtime":5,"relpermalink":"/blog/scg-03/","summary":"摘要:本文主要介绍了什么是GatewayFilter和GlobalFilter，以及区别和联系。然后介绍如何在Spring Cloud Gateway中","tags":["Spring Cloud Gateway"],"title":"Spring Cloud Gateway中的GatewayFilter和GlobalFilter","type":"blog","url":"/blog/scg-03/","wordcount":2441},{"author":"许进","categories":"Spring Cloud Gateway","content":" 摘要:本篇文章主要介绍了Spring Cloud Gateway的基于服务发现的默认路由规则，从中可以看出Gateway的路由规则:http://Gateway_HOST:Gateway_PORT/大写的serviceId/* 和 zuul的默认路由规则http://ZUUL_HOST:ZUUL_PORT/微服务在Eureka上的serviceId/*差不多。\n1.Spring Gateway概述 1.1 什么是Spring Cloud Gateway Spring Cloud Gateway是Spring官方基于Spring 5.0，Spring Boot 2.0和Project Reactor等技术开发的网关，Spring Cloud Gateway旨在为微服务架构提供一种简单而有效的统一的API路由管理方式。Spring Cloud Gateway作为Spring Cloud生态系中的网关，目标是替代Netflix ZUUL，其不仅提供统一的路由方式，并且基于Filter链的方式提供了网关基本的功能，例如：安全，监控/埋点，和限流等。\n1.2 Spring Cloud Gateway的功能 Spring Cloud Gateway 的特征： * 基于 Spring Framework 5，Project Reactor 和 Spring Boot 2.0 动态路由 * Predicates 和 Filters 作用于特定路由 * 集成 Hystrix 断路器 * 集成 Spring Cloud DiscoveryClient * 易于编写的 Predicates 和 Filters * 限流 * 路径重写\n2. Spring Cloud Gateway的工程流程 客户端向 Spring Cloud Gateway 发出请求。然后在 Gateway Handler Mapping 中找到与请求相匹配的路由，将其发送到 Gateway Web Handler。Handler 再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。 过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前（“pre”）或之后（“post”）执行业务逻辑。\n2.1 Pre和POST两种类型的过滤器 3.基于服务发现的默认路由规则 3.1 zuul和gateway的默认路由规则 3.1.1 zuul的默认路由规则 说明默认情况下，Zuul会代理所有注册到Eureka Server的微服务，并且Zuul的路由规则如下： http://ZUUL_HOST:ZUUL_PORT/微服务在Eureka上的serviceId/** 会被转发到serviceId对应的微服务。 http://localhost:8040/sc-zuul-first-provider/sc/order/2\n3.1.2 gateway的默认路由规则 下面的案例中会演示：http://localhost:9000/SC-CONSUMER/hello/xujin \u0026amp;gt;http://Gateway_HOST:Gateway_PORT/大写的serviceId/**，其中微服务应用名默认大写访问。\n3.2 案例示例代码 https://github.com/SoftwareKing/sc-gateway/tree/master/ch1\n   模块 说明 端口     ch1-sc-consumer 服务消费者 8000   ch1-sc-eureka Eureka Server注册中心 8761   ch1-sc-gateway Spring Cloud Gateway Sever 9000   ch1-sc-provider 服务提供者 8001    3.2.1 ch1-sc-gateway工程说明 3.2.1.1 Maven依赖 Spring Cloud Gateway sever主要的maven依赖如下所示\n\u0026amp;lt;dependencies\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-gateway\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-netflix-eureka-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;/dependencies\u0026amp;gt;  3.2.1.2 yml文件配置 spring: application: name: sc-gateway-server cloud: gateway: discovery: locator: enabled: true server: port: 9000 eureka: client: service-url: defaultZone: http://localhost:8761/eureka/ logging: level: org.springframework.cloud.gateway: debug  配置说明：\n spring.cloud.gateway.discovery.locator.enabled：是否与服务发现组件进行结合，通过 serviceId 转发到具体的服务实例。默认为false，设为true便开启通过服务中心的自动根据 serviceId 创建路由的功能。\n  修改spring cloud gateway server监听的端口为9000\n  eureka.client.service-url.defaultZone: http://localhost:8761/eureka/,指定注册中心的地址，Spring Cloud Gateway从注册中心获取已经注册的服务列表。\n  logging.level.org.springframework.cloud.gateway: debug,开启spring-Cloud-gateway的日志级别为debug，方便debug调试。\n 3.3 启动测试 3.3.1 错误的路由规则访问 访问Spring Cloud Gateway对应的server，当访问http://localhost:9000/sc-consumer/hello/xujin的时候，报错如下所示，正确的Spring Cloud Gateway的默认路由规则:http://Gateway_HOST:Gateway_PORT/大写的serviceId/**\n2018-05-18 01:10:49.742 DEBUG 6462 --- [ctor-http-nio-5] …","date":1568635200,"description":"本篇文章主要介绍了Spring Cloud Gateway的基于服务发现的默认路由规则，从中可以看出Gateway的路由规则:http://Gateway_HOST:Gateway_PORT/大写的serviceId/* 和 zuul的默认路由规则http://ZUUL_HOST:ZUUL_PORT/微服务在Eureka上的serviceId/*差不多。","dir":"blog/scg-05/","fuzzywordcount":2200,"kind":"page","lang":"zh","lastmod":1568635200,"objectID":"f4e10165d1ff5f623b0311c5575caeb3","permalink":"/blog/scg-05/","publishdate":"2019-09-16T20:00:00+08:00","readingtime":5,"relpermalink":"/blog/scg-05/","summary":"摘要:本篇文章主要介绍了Spring Cloud Gateway的基于服务发现的默认路由规则，从中可以看出Gateway的路由规则:http://Gat","tags":["Spring Cloud Gateway"],"title":"Spring Cloud Gateway基于服务发现的默认路由规则","type":"blog","url":"/blog/scg-05/","wordcount":2160},{"author":"许进","categories":"Spring Cloud Gateway","content":" 摘要:在上本篇文章Spring Cloud Gateway的After路由断言工厂介绍了Spring Cloud Gateway核心概念和After路由断言，本文简单介绍Before路由断言工厂。因为比较简单所以就抛砖引玉，旨在帮助大家快速入门Spring Cloud Gateway，欢迎大家加我微信Software_King，进入Spring Cloud中国社区微信群交流。\n1. Spring Cloud Gateway核心概念 网关简单的说就是提供一个对外统一的API入口和出口，统管企业对外的所有API出口。一般来说，网关对外暴露的URL或者接口信息，我们统称之为路由信息。如果研发过网关中间件，或者使用或了解过ZUUL的，网关的核心肯定是Filter以及Filter Chain(Filter责任链)。Spring Cloud Gateway也具有路由信息和Filter。下面介绍一下Spring Cloud gateway中最重要的几个概念: * 路由(route):路由是网关最基础的部分，路由信息由一个ID、一个目的url、一组断言工厂和一组Filter组成。如果路由断言工厂为真，则说明请求的Url和配置的路由匹配。 * 断言(Predicate): java 8中的断言函数。Spring Cloud Gateway中的断言函数输入类型是Spring 5.0框架中的ServerWebExchange。Spring Cloud Gateway中的断言函数允许开发者去定义匹配来自于http request中的任何信息，比如请求头和参数等。 * 过滤器(filter):一个标准的Spring webFilter。Spring Cloud Gateway中的Filter分为两种类型的Filter，分别是Gateway Filter和Global Filter.网关 Filter实例是由Spring 框架中的网关Filter的特殊工厂构造。request在转发到目前服务之前，response在返回到调用端之前都可以被修改或者自定义。\n2. 什么是Before路由断言 Before路由断言工厂带有一个UTC时间格式的时间参数，当请求进来的当前时间在路由断言工厂之前会成功匹配，否则不能成功匹配。\n3. Before路由断言工厂的案例 3.1 引入pom依赖 pom.xml依赖配置如下所示:\n\u0026amp;lt;properties\u0026amp;gt; \u0026amp;lt;spring-cloud.version\u0026amp;gt;Finchley.M9\u0026amp;lt;/spring-cloud.version\u0026amp;gt; \u0026amp;lt;/properties\u0026amp;gt; \u0026amp;lt;dependencyManagement\u0026amp;gt; \u0026amp;lt;dependencies\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-dependencies\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${spring-cloud.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;type\u0026amp;gt;pom\u0026amp;lt;/type\u0026amp;gt; \u0026amp;lt;scope\u0026amp;gt;import\u0026amp;lt;/scope\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;/dependencies\u0026amp;gt; \u0026amp;lt;/dependencyManagement\u0026amp;gt; \u0026amp;lt;dependencies\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-actuator\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-gateway\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-devtools\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;scope\u0026amp;gt;runtime\u0026amp;lt;/scope\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-test\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;scope\u0026amp;gt;test\u0026amp;lt;/scope\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-webflux\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;/dependencies\u0026amp;gt; \u0026amp;lt;build\u0026amp;gt; \u0026amp;lt;plugins\u0026amp;gt; \u0026amp;lt;plugin\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-maven-plugin\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/plugin\u0026amp;gt; \u0026amp;lt;/plugins\u0026amp;gt; \u0026amp;lt;/build\u0026amp;gt; \u0026amp;lt;repositories\u0026amp;gt; \u0026amp;lt;repository\u0026amp;gt; \u0026amp;lt;id\u0026amp;gt;spring-snapshots\u0026amp;lt;/id\u0026amp;gt; \u0026amp;lt;name\u0026amp;gt;Spring Snapshots\u0026amp;lt;/name\u0026amp;gt; \u0026amp;lt;url\u0026amp;gt;https://repo.spring.io/snapshot\u0026amp;lt;/url\u0026amp;gt; \u0026amp;lt;snapshots\u0026amp;gt; \u0026amp;lt;enabled\u0026amp;gt;true\u0026amp;lt;/enabled\u0026amp;gt; \u0026amp;lt;/snapshots\u0026amp;gt; \u0026amp;lt;/repository\u0026amp;gt; \u0026amp;lt;repository\u0026amp;gt; \u0026amp;lt;id\u0026amp;gt;spring-milestones\u0026amp;lt;/id\u0026amp;gt; \u0026amp;lt;name\u0026amp;gt;Spring Milestones\u0026amp;lt;/name\u0026amp;gt; …","date":1568635200,"description":"在上本篇文章Spring Cloud Gateway的After路由断言工厂介绍了Spring Cloud Gateway核心概念和After路由断言，本文简单介绍Before路由断言工厂。因为比较简单所以就`抛砖引玉，旨在帮助大家快速入门Spring Cloud Gateway`，欢迎大家`加我微信Software_King`，进入Spring Cloud中国社区微信群交流","dir":"blog/scg-06/","fuzzywordcount":1300,"kind":"page","lang":"zh","lastmod":1568635200,"objectID":"d0fba303626198b42f1309b342162467","permalink":"/blog/scg-06/","publishdate":"2019-09-16T20:00:00+08:00","readingtime":3,"relpermalink":"/blog/scg-06/","summary":"摘要:在上本篇文章Spring Cloud Gateway的After路由断言工厂介绍了Spring Cloud Gateway核心概念和After路由断言，本文简","tags":["Spring Cloud Gateway"],"title":"Spring Cloud Gateway的Before路由断言工厂","type":"blog","url":"/blog/scg-06/","wordcount":1255},{"author":"许进","categories":"Spring Cloud Gateway","content":" 1.前言 网关中有两个重要的概念，那就是路由配置和路由规则，路由配置是指配置某请求路径路由到指定的目的地址。而路由规则是指匹配到路由配置之后，再根据路由规则进行转发处理。 Spring Cloud Gateway作为所有请求流量的入口，在实际生产环境中为了保证高可靠和高可用，尽量避免重启,需要实现Spring Cloud Gateway动态路由配置。前面章节介绍了Spring Cloud Gateway提供的两种方法去配置路由规则，但都是在Spring Cloud Gateway启动时候，就将路由配置和规则加载到内存里，无法做到不重启网关就可以动态的对应路由的配置和规则进行增加，修改和删除。`本篇文章简单介绍如何实现Spring Cloud Gateway的动态路由。\n2. Spring Cloud Gateway简单的动态路由实现 Spring Cloud Gateway的官方文档并没有讲如何动态配置，查看 Spring Cloud Gateway的源码，发现在org.springframework.cloud.gateway.actuate.GatewayControllerEndpoint类中提供了动态配置的Rest接口，但是需要开启Gateway的端点，而且提供的功能不是很强大。通过参考和GatewayControllerEndpoint相关的代码，可以自己编码实际动态路由配置。 下面通过案例的方式去讲解怎么实现Gateway的动态路由配置。案例工程如ch18-7-gateway所示。\n 代码地址:https://github.com/SpringCloud/spring-cloud-code/blob/master/ch18-7/ch18-7-gateway\n 3. 简单动态路由的实现 3.1 新建Maven工程ch18-7-gateway 配置主要的核心依赖如代码清单18-33所示： 代码清单: ch18-7/ch18-7-gateway/pom.xml\n\u0026amp;lt;dependencies\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-gateway\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-webflux\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-actuator\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;/dependencies\u0026amp;gt;  3.2 根据Spring Cloud Gateway的路由模型定义数据传输模型 分别创建GatewayRouteDefinition.java, GatewayPredicateDefinition.java, GatewayFilterDefinition.java这三个类。 (1) 创建路由定义模型如下代码清单18-34所示： 代码清单 18-34: ch18-7/ch18-7-gateway/src/main/java/cn/springcloud/book/gateway/model/GatewayRouteDefinition.java\npublic class GatewayRouteDefinition { //路由的Id private String id; //路由断言集合配置 private List\u0026amp;lt;GatewayPredicateDefinition\u0026amp;gt; predicates = new ArrayList\u0026amp;lt;\u0026amp;gt;(); //路由过滤器集合配置 private List\u0026amp;lt;GatewayFilterDefinition\u0026amp;gt; filters = new ArrayList\u0026amp;lt;\u0026amp;gt;(); //路由规则转发的目标uri private String uri; //路由执行的顺序 private int order = 0; //此处省略get和set方法 }  (2)创建过滤器定义模型,代码如代码清单18-35所示： 代码清单18-35: ch18-7/ch18-7-gateway/src/main/java/cn/springcloud/book/gateway/model/GatewayFilterDefinition.java\npublic class GatewayFilterDefinition { //Filter Name private String name; //对应的路由规则 private Map\u0026amp;lt;String, String\u0026amp;gt; args = new LinkedHashMap\u0026amp;lt;\u0026amp;gt;(); //此处省略Get和Set方法 }  (3)路由断言定义模型，代码如代码清单18-36所示: 代码清单18-36: ch18-7/ch18-7-gateway/src/main/java/cn/springcloud/book/gateway/model/GatewayPredicateDefinition.java\npublic class GatewayPredicateDefinition { //断言对应的Name private String name; //配置的断言规则 private Map\u0026amp;lt;String, String\u0026amp;gt; args = new LinkedHashMap\u0026amp;lt;\u0026amp;gt;(); //此处省略Get和Set方法 }  3.3 编写动态路由实现类 编写DynamicRouteServiceImpl并实现ApplicationEventPublisherAware接口，代码如代码清单18-37所示: ch18-37/ch18-7-gateway/src/main/java/cn/springcloud/book/gateway/route/DynamicRouteServiceImpl.java\n@Service public class DynamicRouteServiceImpl implements ApplicationEventPublisherAware { @Autowired private RouteDefinitionWriter routeDefinitionWriter; private ApplicationEventPublisher …","date":1568635200,"description":"本文主要介绍了Spring Cloud Gateway的动态路由的简单实现方式","dir":"blog/scg-dmy-route/","fuzzywordcount":2200,"kind":"page","lang":"zh","lastmod":1568635200,"objectID":"680d0fc1e514c0358efcb358f76e3aad","permalink":"/blog/scg-dmy-route/","publishdate":"2019-09-16T20:00:00+08:00","readingtime":5,"relpermalink":"/blog/scg-dmy-route/","summary":"1.前言 网关中有两个重要的概念，那就是路由配置和路由规则，路由配置是指配置某请求路径路由到指定的目的地址。而路由规则是指匹配到路由配置之后，","tags":["Spring Cloud Gateway"],"title":"Spring Cloud Gateway的动态路由的简单实现方式","type":"blog","url":"/blog/scg-dmy-route/","wordcount":2175},{"author":"许进","categories":"Spring Cloud Gateway","content":" 1.权重路由 1.1 权重路由使用场景 在开发或者测试的时候，或者线上发布，线上服务多版本控制的时候，需要对服务提供权重路由，最常见的使用就是，一个服务有两个版本，旧版本V1，新版本v2。在线上灰度的时候，需要通过网关动态实时推送，路由权重信息。比如95%的流量走服务v1版本，5%的流量走服务v2版本。\n issue: The Spring Cloud Gateway issue of Allow Rolling Deployments https://github.com/spring-cloud/spring-cloud-gateway/issues/67\n 1.2 Spring Cloud Gateway权重路由原理 Spring Cloud Gateway中提供了org.springframework.cloud.gateway.handler.predicate.WeightRoutePredicateFactory去实现根据分组设置权重进行路由，因此使用起来相对比较简单，有兴趣的可以debug阅读源码。\npublic class WeightRoutePredicateFactory extends AbstractRoutePredicateFactory\u0026amp;lt;WeightConfig\u0026amp;gt; implements ApplicationEventPublisherAware { private static final Log log = LogFactory.getLog(WeightRoutePredicateFactory.class); public static final String GROUP_KEY = WeightConfig.CONFIG_PREFIX + \u0026amp;quot;.group\u0026amp;quot;; public static final String WEIGHT_KEY = WeightConfig.CONFIG_PREFIX + \u0026amp;quot;.weight\u0026amp;quot;; private ApplicationEventPublisher publisher; public WeightRoutePredicateFactory() { super(WeightConfig.class); } @Override public void setApplicationEventPublisher(ApplicationEventPublisher publisher) { this.publisher = publisher; } @Override public List\u0026amp;lt;String\u0026amp;gt; shortcutFieldOrder() { return Arrays.asList(GROUP_KEY, WEIGHT_KEY); } @Override public String shortcutFieldPrefix() { return WeightConfig.CONFIG_PREFIX; } @Override public void beforeApply(WeightConfig config) { if (publisher != null) { publisher.publishEvent(new WeightDefinedEvent(this, config)); } } @Override public Predicate\u0026amp;lt;ServerWebExchange\u0026amp;gt; apply(WeightConfig config) { return exchange -\u0026amp;gt; { Map\u0026amp;lt;String, String\u0026amp;gt; weights = exchange.getAttributeOrDefault(WEIGHT_ATTR, Collections.emptyMap()); String routeId = exchange.getAttribute(GATEWAY_PREDICATE_ROUTE_ATTR); // all calculations and comparison against random num happened in // WeightCalculatorWebFilter String group = config.getGroup(); if (weights.containsKey(group)) { String chosenRoute = weights.get(group); if (log.isTraceEnabled()) { log.trace(\u0026amp;quot;in group weight: \u0026amp;quot;+ group + \u0026amp;quot;, current route: \u0026amp;quot; + routeId +\u0026amp;quot;, chosen route: \u0026amp;quot; + chosenRoute); } return routeId.equals(chosenRoute); } return false; }; } }  2.Spring Cloud Gateway中的权重路由案例 2.1 案例代码地址 https://github.com/SoftwareKing/sc-gateway/tree/master/ch4\n2.2 Spring Cloud Gateway Server说明 Spring Cloud Gateway will dispatch 95% of the requests to version 1 and 5% of the traffic to version 2 of a specified service, as shown by the following figure.\n我们通过在Spring Cloud Gateway中会配置不同的权重信息到不同URL上，Spring Cloud Gateway会根据我们配置的路由权重信息，将请求分发到不同的源服务组，权重信息如ch4/ch4-gateway中的application.yml所示，主要配置信息如下。\nspring: application: name: ch4-gateway cloud: gateway: routes: - id: service1_v1 uri: http://localhost:8081/v1 predicates: - Path=/test - Weight=service1, 95 - id: service1_v2 uri: http://localhost:8081/v2 predicates: - Path=/test - Weight=service1, 5   Weight=service1, 95，Weight=service1, 5就是路由的权重信息。\n 2.3 源服务 源服务在本案例中源服务如ch4-service-provider所示，主要提提供Gateway Server权重路由对应的后端源服务。因为比较简单因此不做详细说明，主要代码如下所示。 …","date":1568635200,"description":"本文主要通过运用Spring Cloud Gateway的WeightRoutePredicateFactory对URL进行权重路由。","dir":"blog/scg-02/","fuzzywordcount":1000,"kind":"page","lang":"zh","lastmod":1568635200,"objectID":"871e57eed714194e7f86d5f3d20d9934","permalink":"/blog/scg-02/","publishdate":"2019-09-16T20:00:00+08:00","readingtime":2,"relpermalink":"/blog/scg-02/","summary":"1.权重路由 1.1 权重路由使用场景 在开发或者测试的时候，或者线上发布，线上服务多版本控制的时候，需要对服务提供权重路由，最常见的使用就是，一个服","tags":["Spring Cloud Gateway"],"title":"Spring Cloud Gateway的权重路由","type":"blog","url":"/blog/scg-02/","wordcount":946},{"author":"许进","categories":"Spring Cloud","content":" 摘要: 随着Eureka不再维护，Hystrix不再开发新功能，进入维护状态。以及最近中国开源出现一些大事，预测一下2019年未来Spring Cloud生态圈中的第二代组件的组合，仅代表个人看法。\n1. Spring Cloud第一代 Spring Cloud自从推出之后，给大家的感觉就是Spring Cloud做它最擅长的事，也就是高度抽象和封装，强强联手整合最优东西为我所用，比如Netflix开源的Eureka，Hystrix，Ribbon等。而且提供多种技术选型，态度中立而选最优。8天前也就是2018年11月19号左右，Netflix的开源项目Hystrix宣布状态，不再开发新功能，处于维护状态。引发朋友圈的一些思考。\n 虽然Eureka，Hystrix等不再继续开发或维护，但是目前来说不影响使用，不管怎么说感谢开源，向Netflix公司的开源致敬。\n 随着Spring Cloud生态圈的发展与成长，Spring Cloud陆续推出了自己的一些组件，挑选主要组件说明如下表所示:\n   组件 来源 说明     Spring-cloud-openfeign 基于Feign的升级 服务之间调用的必备组件   spring-cloud-zuul 来源于Netflix Zuul 目前还在继续维护，但是已经有自己的Spring Cloud Gateway,不久将来逐渐淘汰   spring-cloud-eureka 集成于Netflix Eureka 目前还在跟随Spring Cloud版本升级维护，最终也会被替代   spring-cloud-config 自研 功能不足，国内使用其它配置中心替代，比如携程的Apollo   全链路监控(sleuth+zikpin或pinpont) sleuth自研，其它第三方 国内目前使用最多的是skywaling等上生产   spring-cloud-ribbon 来源于Netflix集成 ribbon目前还在跟随Spring Cloud版本维护中，目前孵化未来替代品spring-cloud-lb   Spring-cloud-hystrix 来源于Netflix集成 目前还在跟随Spring Cloud版本维护中目前已经孵化spring-cloud-r4j    2. Spring Cloud 第二代 Spring Cloud第一代和第二代的组件组合汇总，如下表所示。\n    Spring Cloud第一代 Spring Cloud第二代     网关 Spring Cloud Zuul Spring Cloud Gateway   注册中心 eureka(不再更新)，Consul,ZK 阿里Nacos，拍拍贷radar等可选   配置中心 spring cloud config 阿里Nacos，携程Apollo，随行付Config Keeper   客户端软负载均衡 Ribbon spring-cloud-loadbalancer   熔断器 Hystrix spring-cloud-r4j(Resilience4J)，阿里Sentinel     由于Zuul性能一般，zuul 2.x(一直跳票，虽最终开源）但是Spring Cloud官方已经推出Spring Cloud gateway,Spring Cloud中国社区很久之前已经证实，Spring Cloud将不会集成zuul 2.x，也就是说在不就未来Zuul将从Spring Cloud生态圈中退出。\n  ribbon由于不支持webFlux的负载均衡，Spring Cloud官方很早就在孵化器项目中孵化spring-cloud-loadbalancer，目前已经将代码合并到spring-cloud-common中，预计在Spring Cloud G版可以使用，预计2018年12月底realese。\n  至于Hystrix，Netflix在2018年11月19号左右，Netflix的开源项目Hystrix宣布状态，不再开发新功能，处于维护状态，其实在之前Spring Cloud官方就在孵化spring-cloud-r4j.\n 3.开源项目的链接 本文所提到的开源项目链接汇总如下所示：\nhttps://github.com/alibaba/Sentinel\nhttps://github.com/spring-cloud-incubator/spring-cloud-r4j\n阿里Nacos-https://github.com/alibaba/nacos\n随行付Config-keeper-https://github.com/sxfad/config-keeper\nspring-cloud-loadbalancer\nhttps://github.com/ctripcorp/apollo\nhttps://github.com/apache/incubator-skywalking\n","date":1568635200,"description":"随着Eureka不再维护，Hystrix不再开发新功能，进入维护状态。以及最近中国开源出现一些大事，预测一下2019年未来Spring Cloud生态圈中的第二代组件的组合，仅代表个人看法","dir":"blog/sc-2/","fuzzywordcount":1500,"kind":"page","lang":"zh","lastmod":1568635200,"objectID":"02d95b1104da8ff37650da89b3170f26","permalink":"/blog/sc-2/","publishdate":"2019-09-16T20:00:00+08:00","readingtime":3,"relpermalink":"/blog/sc-2/","summary":"摘要: 随着Eureka不再维护，Hystrix不再开发新功能，进入维护状态。以及最近中国开源出现一些大事，预测一下2019年未来Spring","tags":["Spring Cloud"],"title":"Spring Cloud第二代","type":"blog","url":"/blog/sc-2/","wordcount":1472},{"author":"许进","categories":"Spring Cloud Gateway","content":" 1.前言 网关中有两个重要的概念，那就是路由配置和路由规则，路由配置是指配置某请求路径路由到指定的目的地址。而路由规则是指匹配到路由配置之后，再根据路由规则进行转发处理。 Spring Cloud Gateway作为所有请求流量的入口，在实际生产环境中为了保证高可靠和高可用，尽量避免重启,需要实现Spring Cloud Gateway动态路由配置。前面章节介绍了Spring Cloud Gateway提供的两种方法去配置路由规则，但都是在Spring Cloud Gateway启动时候，就将路由配置和规则加载到内存里，无法做到不重启网关就可以动态的对应路由的配置和规则进行增加，修改和删除。本文是基于Spring Cloud Gateway的动态路由实现 基础之上编写，通过Nacos配置服务下发路由配置实现动态路由。\n2. Spring Cloud Gateway简单的动态路由实现 Spring Cloud Gateway的官方文档并没有讲如何动态配置，查看 Spring Cloud Gateway的源码，发现在org.springframework.cloud.gateway.actuate.GatewayControllerEndpoint类中提供了动态配置的Rest接口，但是需要开启Gateway的端点，而且提供的功能不是很强大。通过参考和GatewayControllerEndpoint相关的代码，可以自己编码实际动态路由配置。 下面通过案例的方式去讲解怎么通Nacos实现Spring Cloud Gateway的动态路由。案例工程如spring-cloud-gateway-nacos所示。\n 代码地址:https://github.com/SpringCloud/spring-cloud-gateway-nacos\n 3. 简单动态路由的实现 3.1 新建Maven工程sc-gateway-server 配置主要的核心依赖如代码清单所示： 代码清单: spring-cloud-gateway-nacos/sc-gateway-server/pom.xml\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-gateway\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alibaba.nacos\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;nacos-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;0.4.0\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-webflux\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-actuator\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alibaba\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;fastjson\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;1.2.47\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  3.2 根据Spring Cloud Gateway的路由模型定义数据传输模型 分别创建GatewayRouteDefinition.java, GatewayPredicateDefinition.java, GatewayFilterDefinition.java这三个类。 (1) 创建路由定义模型\npublic class GatewayRouteDefinition { //路由的Id private String id; //路由断言集合配置 private List\u0026amp;lt;GatewayPredicateDefinition\u0026amp;gt; predicates = new ArrayList\u0026amp;lt;\u0026amp;gt;(); //路由过滤器集合配置 private List\u0026amp;lt;GatewayFilterDefinition\u0026amp;gt; filters = new ArrayList\u0026amp;lt;\u0026amp;gt;(); //路由规则转发的目标uri private String uri; //路由执行的顺序 private int order = 0; //此处省略get和set方法 }  (2)创建过滤器定义模型\npublic class GatewayFilterDefinition { //Filter Name private String name; //对应的路由规则 private Map\u0026amp;lt;String, String\u0026amp;gt; args = new LinkedHashMap\u0026amp;lt;\u0026amp;gt;(); //此处省略Get和Set方法 }  (3)创建路由断言定义模型\npublic class GatewayPredicateDefinition { //断言对应的Name private String name; //配置的断言规则 private Map\u0026amp;lt;String, String\u0026amp;gt; args = new LinkedHashMap\u0026amp;lt;\u0026amp;gt;(); //此处省略Get和Set方法 }  3.3 编写动态路由实现类 编写DynamicRouteServiceImpl并实现ApplicationEventPublisherAware接口，代码如下所示\n@Service public class DynamicRouteServiceImpl implements ApplicationEventPublisherAware { @Autowired private RouteDefinitionWriter routeDefinitionWriter; private ApplicationEventPublisher publisher; //增加路由 public String add(RouteDefinition definition) { routeDefinitionWriter.save(Mono.just(definition)).subscribe(); …","date":1568635200,"description":"本文主要介绍通过Nacos下发路由配置实现Spring Cloud Gateway的动态路由","dir":"blog/scg-nacos-01/","fuzzywordcount":2500,"kind":"page","lang":"zh","lastmod":1568635200,"objectID":"969fce0835ece8dc960882e28fb219e5","permalink":"/blog/scg-nacos-01/","publishdate":"2019-09-16T20:00:00+08:00","readingtime":5,"relpermalink":"/blog/scg-nacos-01/","summary":"1.前言 网关中有两个重要的概念，那就是路由配置和路由规则，路由配置是指配置某请求路径路由到指定的目的地址。而路由规则是指匹配到路由配置之后，","tags":["Spring Cloud Gateway"],"title":"使用Nacos实现Spring Cloud Gateway的动态路由","type":"blog","url":"/blog/scg-nacos-01/","wordcount":2495},{"author":null,"categories":null,"content":" Halo Boot概述 Halo Boot 是基于 Spring Boot 的研发框架，基于Spring Boot 的中间件轻量集成方案，与标准的 Spring Boot 工程无缝集成。其在完美集成各个中间件的前提下对用户提供了易用、统一的编程界面。\n","date":1568246400,"description":"","dir":"projects/halo-boot/overview/","fuzzywordcount":100,"kind":"page","lang":"zh","lastmod":1568246400,"objectID":"4eeda33d905f654466cf4fa4ba02a0cf","permalink":"/projects/halo-boot/overview/","publishdate":"2019-09-12T00:00:00Z","readingtime":1,"relpermalink":"/projects/halo-boot/overview/","summary":"Halo Boot概述 Halo Boot 是基于 Spring Boot 的研发框架，基于Spring Boot 的中间件轻量集成方案，与标准的 Spring Boot 工程无缝集成。其在完美集成各个中间件的前提下对用","tags":null,"title":"Halo Boot 介绍","type":"projects","url":"/projects/halo-boot/overview/","wordcount":85},{"author":"admin","categories":"社区沙龙","content":"  活动主题：Spring Cloud中国社区沙龙-北京站 活动时间：2018-10-28 13:00 ~ 2018-10-28 17:30 活动形式：现场沙龙  介绍 Spring Cloud中国社区(http://springcloud.cn) 是国内基于Spring Cloud微服务体系创建的非盈利技术社区，发展至今刚好两周岁。自2016年10月份创建以来，在北京，上海，深圳，成都等地举办了多次技术沙龙，提供技术交流平台,帮助数万开发者快速学习Spring Cloud并用于生产。\n本次Spring Cloud中国社区两周年技术沙龙活动不仅有资深导师，还有现场抽奖福利相送哦，欢迎大家报名！\n更多访问:https://www.hdb.com/party/ayvf2.html\n","date":1539771600,"description":"Spring Cloud中国社区沙龙-北京站","dir":"activities/sq-01/","fuzzywordcount":400,"kind":"page","lang":"zh","lastmod":1539771600,"objectID":"93f4b48aa2022c564cd7fbd14ffd5f41","permalink":"/activities/sq-01/","publishdate":"2018-10-17T10:20:00Z","readingtime":1,"relpermalink":"/activities/sq-01/","summary":"活动主题：Spring Cloud中国社区沙龙-北京站 活动时间：2018-10-28 13:00 ~ 2018-10-28 17:30 活动形式：现场沙龙 介绍 Spring Cloud中国社区(htt","tags":["社区沙龙","Spring Cloud中国社区"],"title":"Spring Cloud中国社区沙龙-北京站","type":"activities","url":"/activities/sq-01/","wordcount":301},{"author":null,"categories":null,"content":"","date":1536883200,"description":"","dir":"projects/halo/quick-start/","fuzzywordcount":100,"kind":"page","lang":"zh","lastmod":1536883200,"objectID":"e44de85a2e3f1a79945627fd3c6c5023","permalink":"/projects/halo/quick-start/","publishdate":"2018-09-14T00:00:00Z","readingtime":0,"relpermalink":"/projects/halo/quick-start/","summary":"","tags":null,"title":"快速开始","type":"projects","url":"/projects/halo/quick-start/","wordcount":0},{"author":null,"categories":null,"content":" 1.Halo Framework概述 Halo Framework是将DDD，洋葱架构，整洁架构，读写分离架构有机整合一起，基于业务身份+扩展点的设计思想，采用应用内部流程编排的方式形成可复用的业务资产库。最终架构落地达到业务与业务隔离，业务与平台隔离，管理域与运行域分开，帮助企业快速落地业务中台。\nHalo设计原则简单，即在高内聚，低耦合，可扩展，易理解的指导思想下，尽可能的贯彻面向对象的设计思想和领域驱动设计的原则。\n Halo Framework是基于DDD+CQRS+扩展点的应用框架，业务系统使用之自带光环!\n 2. Halo主要模块 Halo Framework的主要模块如下所示:\nhalo-cqrs：读写分离架构-所有请求封装为命令对象，通过Command Bus分发到命令处理器执行，通过Event和Event Bus等实现读写分离。\n halo-ddd: 根据领域驱动设计思想，自定义注解 @Entity(实体)，@Factory(工厂), @DomainService(领域服务), @ValueObject(值对象)，@DomainRepository(资源库)，@DomainAbility(域能力) 等进行战术设计，落地DDD，实现 业务与业务 隔离。\n Halo Admin: 中台可视化管控平台，全链路可视化视角，对业务资产进行可视化。\n Halo Boot: 基于Spring Boot定制的Starter。包含Halo Web，Halo Swagger，Halo ES6，Halo Job,Halo Test,Halo MyBatis等\n halo-extension：基于扩展点的设计思想，自定义 @ExtensionPoint(扩展点注解) 和 @Extension(扩展注解), 实现 平台和插件 隔离。\n halo-flow: 基于流程编排思想，开发业务组件，编排应用内部已有业务资产，快速响应前台需求，久而久之形成大量可复用的业务组件库。\n Halo ToolKit: 一款IDEA插件，只为加速Halo应用开发而生。\n Halo Codegen: 通过设计代码生成器, 快速生成最佳实践的基础代码和规范，提高开发效率和生产力，让业务开发人员专注于业务开发。\n Halo Plugin: Halo生态体系中的Gradle或Maven插件。\n Halo Check:基于Git Hook+JGit+CheckStyle+PMD对代码增量diff Check是否满足Halo Style。该项目主要用于Git Commit提交的时候对代码进行检查。分为客户端和Gitlab服务端Check 。\n  3. Halo Framework设计 4.1 Halo Framework设计思想 Halo框架的主要思想是 流程组合节点,节点调用域服务,域服务包含若干域能力,域能力下若干个业务扩展。\n 业务包与平台分离的插件化架构： 平台提供插件包注册机制，实现业务方插件包在运行期的注册。业务代码只允许存在于插件包中， 与平台代码严格分离。业务包的代码配置库也与平台的代码库分离，通过二方包的方式，提供给容器加载\n 全链路统一的业务身份：\n平台需要能有按“业务身份”进行业务与业务之间逻辑隔离的能力，而不是传统SPI架构不区分业务身份， 简单过滤的方式。如何设计这个业务身份，也成为业务间隔离架构的关键。\n 管理域与运行域分离： 业务逻辑不能依靠运行期动态计算，要能在静态期进行定义并可视化呈现。 业务定义中出现的规则叠加冲突，也在静态器进行冲突决策。在运行期，严格按照静态器定义的业务规则、冲突决策策略执行。\n  4.2 Halo架构 对外的一切请求交互调用，全部适配为命令。命令进入应用层服务-\u0026amp;gt;域服务-\u0026amp;gt;域能力。域能力基于接口的方式调用基础设施层的服务。如下图所示:\n4.3 Halo对产品生命周期的支持 ","date":1536710400,"description":"","dir":"projects/halo/overview/","fuzzywordcount":1500,"kind":"page","lang":"zh","lastmod":1536710400,"objectID":"1c0eabc80d52d3a471789f3649e676a0","permalink":"/projects/halo/overview/","publishdate":"2018-09-12T00:00:00Z","readingtime":3,"relpermalink":"/projects/halo/overview/","summary":"1.Halo Framework概述 Halo Framework是将DDD，洋葱架构，整洁架构，读写分离架构有机整合一起，基于业务身份+扩展点的设计思想，采用应","tags":null,"title":"Halo 介绍","type":"projects","url":"/projects/halo/overview/","wordcount":1422},{"author":null,"categories":null,"content":" Q: Halo Flow有啥应用场景？ 应用内部流程编排\nQ: Halo DDD是什么？ Halo DDD是Halo框架对领域驱动的封装\n","date":1536710400,"description":"","dir":"projects/halo/faq/","fuzzywordcount":100,"kind":"page","lang":"zh","lastmod":1536710400,"objectID":"198a0121280caeeaef0d1e43aef5025f","permalink":"/projects/halo/faq/","publishdate":"2018-09-12T00:00:00Z","readingtime":1,"relpermalink":"/projects/halo/faq/","summary":"Q: Halo Flow有啥应用场景？ 应用内部流程编排 Q: Halo DDD是什么？ Halo DDD是Halo框架对领域驱动的封装","tags":null,"title":"常见问题","type":"projects","url":"/projects/halo/faq/","wordcount":49},{"author":null,"categories":null,"content":"Halo使用了一些三方开源组件，他们分别是：\n一些主要依赖：\n Spring under Apache 2.0 license Spring Boot under Apache 2.0 license SLF4j under the MIT License  一些扩展依赖：\n nuxeo under Apache License, Version 2.0  \u0026amp;hellip; 其它整理中。\n","date":1536710400,"description":"","dir":"projects/halo/notice/","fuzzywordcount":100,"kind":"page","lang":"zh","lastmod":1536710400,"objectID":"bc49aaa37163a452cf0c4f82aabd62a8","permalink":"/projects/halo/notice/","publishdate":"2018-09-12T00:00:00Z","readingtime":1,"relpermalink":"/projects/halo/notice/","summary":"Halo使用了一些三方开源组件，他们分别是： 一些主要依赖： Spring under Apache 2.0 license Spring Boot under Apache 2.0 license SLF4j under the MIT License 一些扩展依赖： nuxeo under Apache License, Version 2.0 \u0026hellip; 其它整理中。","tags":null,"title":"版权声明","type":"projects","url":"/projects/halo/notice/","wordcount":65},{"author":null,"categories":null,"content":" 1.CAP概述 CAP-专注于数据一致性领域，为注册中心，开关中心，配置中心，网关提供数据一致性下发的强大基石。\n1.1 CAP命名由来 大家都知道CAP理论。C代表一致性（Consistency），A代表可用性（Availability），P代表分区容错性（Partition Tolerance）。所以直接CAP命名该中间件。 致力解决数据一致性的问题，为各种需要数据一致性的场景，提供统一的方案，像集成Activiti等工作流框架一样，集成到自己的中间件中。\n","date":1531353600,"description":"","dir":"projects/cap/overview/","fuzzywordcount":300,"kind":"page","lang":"zh","lastmod":1531353600,"objectID":"ab676e2e0c184726fa55e8e3a8a5339b","permalink":"/projects/cap/overview/","publishdate":"2018-07-12T00:00:00Z","readingtime":1,"relpermalink":"/projects/cap/overview/","summary":"1.CAP概述 CAP-专注于数据一致性领域，为注册中心，开关中心，配置中心，网关提供数据一致性下发的强大基石。 1.1 CAP命名由来 大家都知道CA","tags":null,"title":"CAP介绍","type":"projects","url":"/projects/cap/overview/","wordcount":224},{"author":null,"categories":null,"content":" 1.Defensor概述 Defensor是Halo Framework的守护神(测试工程)，用于保证Halo生态中框架的质量。\n","date":1531353600,"description":"","dir":"projects/defensor/overview/","fuzzywordcount":100,"kind":"page","lang":"zh","lastmod":1531353600,"objectID":"acb38e245af85e1643814a2232cf2833","permalink":"/projects/defensor/overview/","publishdate":"2018-07-12T00:00:00Z","readingtime":1,"relpermalink":"/projects/defensor/overview/","summary":"1.Defensor概述 Defensor是Halo Framework的守护神(测试工程)，用于保证Halo生态中框架的质量。","tags":null,"title":"Defensor介绍","type":"projects","url":"/projects/defensor/overview/","wordcount":62},{"author":null,"categories":null,"content":" 1.Janus概述 Janus网关中间件，掌管着企业级服务对外提供所有请求的入口和出口。功能包括协议适配，协议转发等。\n1.1 Janus命名由来 在罗马神话中Janus（汉译作“杰纳斯”或“雅努斯”）是天门神，早晨打开天门，让阳光普照人间，晚上又把天门关上，使黑暗降临大地。\n他的头部前后各有一副面孔，如上图所示，同时看着两个不同方向，一副看着过去，一副看着未来，因此也称两面神，或被尊称为时间之神。罗马有好几座Janus神庙。Janus掌管所有的出入门户，因此罗马人在战时永远将杰纳斯神殿的门敞开着，以便军人在败阵时躲入殿内以求庇护，或是在战胜时凯旋入殿。\n1.2 Janus的功能 网关该具备的最基本的四大功能:统一接入，流量管控，协议适配转发，安全防护。 基于Netty的Janus架构 2.1 设计原则  1.每个Filter基于责任链，只做专一的一件事 2.每个Filter有各自独立的数据 3.损耗性能的Filter顺序往后放 4.启动读取配置顺序，先远端，若远端失败，则读取本地。 5.集群网关，要注意数据的diff和灰度 6.尽量做到和服务治理框架解耦，易于接入，易于升级  Janus的核心设计 http://janus.xujin.org\n","date":1531353600,"description":"","dir":"projects/janus/overview/","fuzzywordcount":500,"kind":"page","lang":"zh","lastmod":1531353600,"objectID":"552a34b40d60d7f2ae7225b6b04466c3","permalink":"/projects/janus/overview/","publishdate":"2018-07-12T00:00:00Z","readingtime":1,"relpermalink":"/projects/janus/overview/","summary":"1.Janus概述 Janus网关中间件，掌管着企业级服务对外提供所有请求的入口和出口。功能包括协议适配，协议转发等。 1.1 Janus命名由来 在罗","tags":null,"title":"Janus网关介绍","type":"projects","url":"/projects/janus/overview/","wordcount":482},{"author":"许进","categories":"Spring Cloud Gateway","content":" 摘要:Spring Cloud Gateway只有两种类型的Filter，本文介绍如何在Spring Cloud Gateway中创建一个Pre或Post类型的Filter。\nzuul的Filter类型 Zuul 的 Filter 是通过filterType()方法来指定，一个 Filter 只能对应一种类型，要么是 “pre” 要么是“post”\nSpring Cloud Gateway的Filter类型 Spring Cloud Gateway 基于 Project Reactor 和 WebFlux，采用响应式编程风格，打开它的 Filter 的接口GatewayFilter你会发现它只有一个方法filter\nPre类型的Filter 在Spring Cloud Gateway源码中定义了一个Pre类型的Filter，code将会在chain.filter() 之前被执行,代码:AddRequestHeader\npackage org.springframework.cloud.gateway.filter.factory; import org.springframework.cloud.gateway.filter.GatewayFilter; import org.springframework.http.server.reactive.ServerHttpRequest; /** * @author Spencer Gibb */ public class AddRequestHeaderGatewayFilterFactory extends AbstractNameValueGatewayFilterFactory { @Override public GatewayFilter apply(NameValueConfig config) { return (exchange, chain) -\u0026amp;gt; { ServerHttpRequest request = exchange.getRequest().mutate() .header(config.getName(), config.getValue()) .build(); return chain.filter(exchange.mutate().request(request).build()); }; } }  Post类型的Filter 对于Post类型的Filter，SetStatus 代码将会在chain.filter(exchange).then()里面的代码运行。\npublic class SetStatusGatewayFilterFactory extends AbstractGatewayFilterFactory\u0026amp;lt;SetStatusGatewayFilterFactory.Config\u0026amp;gt; { @Override public GatewayFilter apply(Config config) { final HttpStatus status = ServerWebExchangeUtils.parse(config.status); return (exchange, chain) -\u0026amp;gt; { return chain.filter(exchange).then(Mono.fromRunnable(() -\u0026amp;gt; { // check not really needed, since it is guarded in setStatusCode, // but it\u0026#39;s a good example if (!exchange.getResponse().isCommitted()) { setResponseStatus(exchange, status); } })); }; } }  ","date":1526904000,"description":"Spring Cloud Gateway只有两种类型的Filter，本文介绍如何在Spring Cloud Gateway中创建一个Pre或Post类型的Filter","dir":"blog/scg-04/","fuzzywordcount":500,"kind":"page","lang":"zh","lastmod":1526904000,"objectID":"51ce631c9eb7e07fa908f9e83bcdebf9","permalink":"/blog/scg-04/","publishdate":"2018-05-21T20:00:00+08:00","readingtime":1,"relpermalink":"/blog/scg-04/","summary":"摘要:Spring Cloud Gateway只有两种类型的Filter，本文介绍如何在Spring Cloud Gateway中创建一个Pre或Post类型的Fi","tags":["Spring Cloud Gateway"],"title":"Spring Cloud Gateway只有Pre和POST两种类型的Filter","type":"blog","url":"/blog/scg-04/","wordcount":491},{"author":"许进","categories":"Eureka Server","content":" 1. Spring Cloud中国公益Eureka Server Eureka Server为作为Spring Cloud开发过程中常用的注册中心组件，作为基础设施组件，开发学习过程中，经常需要自己创建Eureka Server应用和重启。为了帮助开发者快速学习入门。Spring Cloud中国社区特搭建一个公益注册中心，仅作为帮助Spring Cloud的开发者进行学习和调试。为了更好服务大家，请勿对本注册中心进行压测。定制的Eureka Server注册中心UI如下所示。\n1.1 访问地址 http://eureka.springcloud.cn\n2.定制Eureka Serrver的UI 2.1 为什么要定制Eureka Server 原因两点: * 1.觉得默认的UI比较丑\n* 2.Eureka Server想客制化一下\n 至于Spring Cloud Eureka的UI客制化成什么样子由你而定！\n 3. 两种方法定制Eureka Server 3.1 直接修改eureka server的源代码 直接修改eureka server的源代码，该方法是最纯的方式，而且每次有一个Eureka Server的版本都需要去修改。\n3.2 只修改Eureka Server的UI 只需要修改对应的html+css+文案即可，完全不用去修改Eureka Server的源码,强烈推荐。\n 源码参考地址:https://github.com/SpringCloud/spring-cloud-eureka\n 3.3 为什么我定制自己的UI加进去 为什么我定制自己的UI加进去，就可以直接Run，那源码代码中的UI是不是被覆盖了？\n\u0026amp;lt;dependencies\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;cn.springcloud.eureka\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;eureka-server-ui\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-netflix-eureka-server\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;/dependencies\u0026amp;gt;   如上maven配置所示，官方的spring-cloud-starter-netflix-eureka-server依赖信息配置在下面，由maven的依赖加载顺序决定，定制的UI优先加载显示。\n 4. 如何在项目中使用DIY的Eureka Server 只需要配置maven依赖即可:\n\u0026amp;lt;dependencies\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;cn.springcloud.eureka\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;eureka-server-ui\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-netflix-eureka-server\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;/dependencies\u0026amp;gt;  ","date":1526299200,"description":"本文主要简单介绍如何定制一个eureka server，并直接指出最优的定制方式","dir":"blog/sc-diy-eureka/","fuzzywordcount":800,"kind":"page","lang":"zh","lastmod":1526299200,"objectID":"aebd3e3ed507764a39ede49b02a57758","permalink":"/blog/sc-diy-eureka/","publishdate":"2018-05-14T20:00:00+08:00","readingtime":2,"relpermalink":"/blog/sc-diy-eureka/","summary":"1. Spring Cloud中国公益Eureka Server Eureka Server为作为Spring Cloud开发过程中常用的注册中心组件，作为基础设施组件，开发学习过程中","tags":["Eureka Server"],"title":"公益Eureka Server与定制方法","type":"blog","url":"/blog/sc-diy-eureka/","wordcount":744},{"author":"许进","categories":"Spring Cloud Gateway","content":" 1. Spring Cloud Gateway核心概念 网关简单的说就是提供一个对外统一的API入口和出口，统管企业对外的所有API出口。一般来说，网关对外暴露的URL或者接口信息，我们统称之为路由信息。如果研发过网关中间件，或者使用或了解过ZUUL的，网关的核心肯定是Filter以及Filter Chain(Filter责任链)。Spring Cloud Gateway也具有路由信息和Filter。下面介绍一下Spring Cloud gateway中最重要的几个概念: * 路由(route):路由是网关最基础的部分，路由信息由一个ID、一个目的url、一组断言工厂和一组Filter组成。如果路由断言工厂为真，则说明请求的Url和配置的路由匹配。 * 断言(Predicate): java 8中的断言函数。Spring Cloud Gateway中的断言函数输入类型是Spring 5.0框架中的ServerWebExchange。Spring Cloud Gateway中的断言函数允许开发者去定义匹配来自于http request中的任何信息，比如请求头和参数等。 * 过滤器(filter):一个标准的Spring webFilter。Spring Cloud Gateway中的Filter分为两种类型的Filter，分别是Gateway Filter和Global Filter.网关 Filter实例是由Spring 框架中的网关Filter的特殊工厂构造。request在转发到目前服务之前，response在返回到调用端之前都可以被修改或者自定义。\n2. 什么是Before路由断言 Before路由断言工厂带有一个UTC时间格式的时间参数，当请求进来的当前时间在路由断言工厂之前会成功匹配，否则不能成功匹配。\n3. Before路由断言工厂的案例 3.1 引入pom依赖 pom.xml依赖配置如下所示:\n\u0026amp;lt;properties\u0026amp;gt; \u0026amp;lt;spring-cloud.version\u0026amp;gt;Finchley.M9\u0026amp;lt;/spring-cloud.version\u0026amp;gt; \u0026amp;lt;/properties\u0026amp;gt; \u0026amp;lt;dependencyManagement\u0026amp;gt; \u0026amp;lt;dependencies\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-dependencies\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${spring-cloud.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;type\u0026amp;gt;pom\u0026amp;lt;/type\u0026amp;gt; \u0026amp;lt;scope\u0026amp;gt;import\u0026amp;lt;/scope\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;/dependencies\u0026amp;gt; \u0026amp;lt;/dependencyManagement\u0026amp;gt; \u0026amp;lt;dependencies\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-actuator\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-gateway\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-devtools\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;scope\u0026amp;gt;runtime\u0026amp;lt;/scope\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-test\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;scope\u0026amp;gt;test\u0026amp;lt;/scope\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-webflux\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;/dependencies\u0026amp;gt; \u0026amp;lt;build\u0026amp;gt; \u0026amp;lt;plugins\u0026amp;gt; \u0026amp;lt;plugin\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-maven-plugin\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/plugin\u0026amp;gt; \u0026amp;lt;/plugins\u0026amp;gt; \u0026amp;lt;/build\u0026amp;gt; \u0026amp;lt;repositories\u0026amp;gt; \u0026amp;lt;repository\u0026amp;gt; \u0026amp;lt;id\u0026amp;gt;spring-snapshots\u0026amp;lt;/id\u0026amp;gt; \u0026amp;lt;name\u0026amp;gt;Spring Snapshots\u0026amp;lt;/name\u0026amp;gt; \u0026amp;lt;url\u0026amp;gt;https://repo.spring.io/snapshot\u0026amp;lt;/url\u0026amp;gt; \u0026amp;lt;snapshots\u0026amp;gt; \u0026amp;lt;enabled\u0026amp;gt;true\u0026amp;lt;/enabled\u0026amp;gt; \u0026amp;lt;/snapshots\u0026amp;gt; \u0026amp;lt;/repository\u0026amp;gt; \u0026amp;lt;repository\u0026amp;gt; \u0026amp;lt;id\u0026amp;gt;spring-milestones\u0026amp;lt;/id\u0026amp;gt; \u0026amp;lt;name\u0026amp;gt;Spring Milestones\u0026amp;lt;/name\u0026amp;gt; \u0026amp;lt;url\u0026amp;gt;https://repo.spring.io/milestone\u0026amp;lt;/url\u0026amp;gt; \u0026amp;lt;snapshots\u0026amp;gt; \u0026amp;lt;enabled\u0026amp;gt;false\u0026amp;lt;/enabled\u0026amp;gt; \u0026amp;lt;/snapshots\u0026amp;gt; \u0026amp;lt;/repository\u0026amp;gt; \u0026amp;lt;/repositories\u0026amp;gt; \u0026amp;lt;pluginRepositories\u0026amp;gt; …","date":1522216800,"description":"在上本篇文章Spring Cloud Gateway的After路由断言工厂介绍了Spring Cloud Gateway核心概念和After路由断言，本文简单介绍Before路由断言工厂。因为比较简单所以就`抛砖引玉，旨在帮助大家快速入门Spring Cloud Gateway`，欢迎大家`加我微信Software_King`，进入Spring Cloud中国社区微信群交流","dir":"blog/scg-4-1/","fuzzywordcount":1100,"kind":"page","lang":"zh","lastmod":1522216800,"objectID":"68e4344b578063cf7c480eadaf0525f3","permalink":"/blog/scg-4-1/","publishdate":"2018-03-28T14:00:00+08:00","readingtime":3,"relpermalink":"/blog/scg-4-1/","summary":"1. Spring Cloud Gateway核心概念 网关简单的说就是提供一个对外统一的API入口和出口，统管企业对外的所有API出口。一般来说，网关对外暴露的URL","tags":["Spring Cloud Gateway"],"title":"Spring Cloud Gateway的Before路由断言工厂","type":"blog","url":"/blog/scg-4-1/","wordcount":1085},{"author":"许进","categories":"Spring Cloud Gateway","content":" 摘要:本篇文章主要介绍了Spring Cloud Gateway核心概念和After路由断言，因为比较简单所以就抛砖引玉，旨在帮助大家快速入门Spring Cloud Gateway，欢迎大家加我微信Software_King，进入Spring Cloud中国社区微信群交流。\n1.Spring Cloud Gateway核心概念 网关简单的说就是提供一个对外统一的API入口和出口，统管企业对外的所有API出口。一般来说，网关对外暴露的URL或者接口信息，我们统称之为路由信息。如果研发过网关中间件，或者使用或了解过ZUUL的，网关的核心肯定是Filter以及Filter Chain(Filter责任链)。Spring Cloud Gateway也具有路由信息和Filter。下面介绍一下Spring Cloud gateway中最重要的几个概念:\n 路由(route):路由是网关最基础的部分，路由信息由一个ID、一个目的url、一组断言工厂和一组Filter组成。如果路由断言工厂为真，则说明请求的Url和配置的路由匹配。 断言(Predicate): java 8中的断言函数。Spring Cloud Gateway中的断言函数输入类型是Spring 5.0框架中的ServerWebExchange。Spring Cloud Gateway中的断言函数允许开发者去定义匹配来自于http request中的任何信息，比如请求头和参数等。 过滤器(filter):一个标准的Spring webFilter。Spring Cloud Gateway中的Filter分为两种类型的Filter，分别是Gateway Filter和Global Filter.网关 Filter实例是由Spring 框架中的网关Filter的特殊工厂构造。request在转发到目前服务之前，response在返回到调用端之前都可以被修改或者自定义。  2.什么是After路由断言 After Route Predicate Factory带有一个UTC时间格式的时间参数，当请求进来的当前时间在路由断言工厂之后会成功匹配，否则不能成功匹配。\n3.After路由断言工厂的案例 3.1 引入pom依赖 pom.xml依赖配置如下所示:\n\u0026amp;lt;properties\u0026amp;gt; \u0026amp;lt;spring-cloud.version\u0026amp;gt;Finchley.M9\u0026amp;lt;/spring-cloud.version\u0026amp;gt; \u0026amp;lt;/properties\u0026amp;gt; \u0026amp;lt;dependencyManagement\u0026amp;gt; \u0026amp;lt;dependencies\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-dependencies\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${spring-cloud.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;type\u0026amp;gt;pom\u0026amp;lt;/type\u0026amp;gt; \u0026amp;lt;scope\u0026amp;gt;import\u0026amp;lt;/scope\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;/dependencies\u0026amp;gt; \u0026amp;lt;/dependencyManagement\u0026amp;gt; \u0026amp;lt;dependencies\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-actuator\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-gateway\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-devtools\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;scope\u0026amp;gt;runtime\u0026amp;lt;/scope\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-test\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;scope\u0026amp;gt;test\u0026amp;lt;/scope\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-webflux\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;/dependencies\u0026amp;gt; \u0026amp;lt;build\u0026amp;gt; \u0026amp;lt;plugins\u0026amp;gt; \u0026amp;lt;plugin\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-maven-plugin\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/plugin\u0026amp;gt; \u0026amp;lt;/plugins\u0026amp;gt; \u0026amp;lt;/build\u0026amp;gt; \u0026amp;lt;repositories\u0026amp;gt; \u0026amp;lt;repository\u0026amp;gt; \u0026amp;lt;id\u0026amp;gt;spring-snapshots\u0026amp;lt;/id\u0026amp;gt; \u0026amp;lt;name\u0026amp;gt;Spring Snapshots\u0026amp;lt;/name\u0026amp;gt; \u0026amp;lt;url\u0026amp;gt;https://repo.spring.io/snapshot\u0026amp;lt;/url\u0026amp;gt; \u0026amp;lt;snapshots\u0026amp;gt; \u0026amp;lt;enabled\u0026amp;gt;true\u0026amp;lt;/enabled\u0026amp;gt; \u0026amp;lt;/snapshots\u0026amp;gt; \u0026amp;lt;/repository\u0026amp;gt; \u0026amp;lt;repository\u0026amp;gt; \u0026amp;lt;id\u0026amp;gt;spring-milestones\u0026amp;lt;/id\u0026amp;gt; \u0026amp;lt;name\u0026amp;gt;Spring Milestones\u0026amp;lt;/name\u0026amp;gt; \u0026amp;lt;url\u0026amp;gt;https://repo.spring.io/milestone\u0026amp;lt;/url\u0026amp;gt; …","date":1521979200,"description":"本篇文章主要介绍了Spring Cloud Gateway核心概念和After路由断言，因为比较简单所以就`抛砖引玉，旨在帮助大家快速入门Spring Cloud Gateway`，欢迎大家`加我微信Software_King`，进入Spring Cloud中国社区微信群交流","dir":"blog/scg-07/","fuzzywordcount":1300,"kind":"page","lang":"zh","lastmod":1521979200,"objectID":"e49c0b6cd3d0db865ccfa6efa135b616","permalink":"/blog/scg-07/","publishdate":"2018-03-25T20:00:00+08:00","readingtime":3,"relpermalink":"/blog/scg-07/","summary":"摘要:本篇文章主要介绍了Spring Cloud Gateway核心概念和After路由断言，因为比较简单所以就抛砖引玉，旨在帮助大家快速入门Sprin","tags":["Spring Cloud Gateway"],"title":" Spring Cloud Gateway的After路由断言工厂","type":"blog","url":"/blog/scg-07/","wordcount":1200},{"author":"许进","categories":"Spring Cloud Gateway","content":" 1.Spring Gateway概述 Spring Cloud Gateway是Spring官方基于Spring 5.0，Spring Boot 2.0和Project Reactor等技术开发的网关，Spring Cloud Gateway旨在为微服务架构提供一种简单而有效的统一的API路由管理方式。Spring Cloud Gateway作为Spring Cloud生态系中的网关，目标是替代Netflix ZUUL，其不仅提供统一的路由方式，并且基于Filter链的方式提供了网关基本的功能，例如：安全，监控/埋点，和限流等。\n2. Spring Cloud gateway请求入口分析 不管是Zuul，还是Spring Cloud Gateway还是基于Netty的自研网关，都会把请求进来的Request，或者返回的Response进行包装，转换提取为网关运行的上下文信息，而在Spring Cloud gateway中网关的上下文为ServerWebExchange。\n2.1 入口HttpServerRequest和HttpServerResponse转换 Spring Cloud Gateway的请求入口，org.springframework.http.server.reactive.ReactorHttpHandlerAdapter#apply方法\n@Override public Mono\u0026amp;lt;Void\u0026amp;gt; apply(HttpServerRequest request, HttpServerResponse response) { NettyDataBufferFactory bufferFactory = new NettyDataBufferFactory(response.alloc()); ServerHttpRequest adaptedRequest; ServerHttpResponse adaptedResponse; try { adaptedRequest = new ReactorServerHttpRequest(request, bufferFactory); adaptedResponse = new ReactorServerHttpResponse(response, bufferFactory); } catch (URISyntaxException ex) { logger.error(\u0026amp;quot;Invalid URL \u0026amp;quot; + ex.getMessage(), ex); response.status(HttpResponseStatus.BAD_REQUEST); return Mono.empty(); } if (adaptedRequest.getMethod() == HttpMethod.HEAD) { adaptedResponse = new HttpHeadResponseDecorator(adaptedResponse); } return this.httpHandler.handle(adaptedRequest, adaptedResponse) .doOnError(ex -\u0026amp;gt; logger.error(\u0026amp;quot;Handling completed with error\u0026amp;quot;, ex)) .doOnSuccess(aVoid -\u0026amp;gt; logger.debug(\u0026amp;quot;Handling completed with success\u0026amp;quot;)); }   PS，代码来源于spring-web-5.0.4.RELEASE.jar 此方法为Spring Cloud Gateway的请求入口方法，该方法的作用就是把接收到的HttpServerRequest或者最终需要返回的HttpServerResponse，包装转换为ReactorServerHttpRequest和ReactorServerHttpResponse。\n 2.2 构造Spring Cloud gateway的上下文ServerWebExchange 在org.springframework.web.server.adapter.HttpWebHandlerAdapter的182行，代码如下所示:\n@Override public Mono\u0026amp;lt;Void\u0026amp;gt; handle(ServerHttpRequest request, ServerHttpResponse response) { ServerWebExchange exchange = createExchange(request, response); return getDelegate().handle(exchange) .onErrorResume(ex -\u0026amp;gt; handleFailure(request, response, ex)) .then(Mono.defer(response::setComplete)); }   createExchange()将ServerHttpRequest ServerHttpResponse构建网关上下文ServerWebExchange。\n  PS:其中org.springframework.web.server.handler.WebHandlerDecorator.getDelegate()通过委托的方式获取一系列需要处理的WebHandler.\n 2.3 进入Filter链 org.springframework.cloud.gateway.handler.FilteringWebHandler#handle方法，即77行，代码如下所示\n@Override public Mono\u0026amp;lt;Void\u0026amp;gt; handle(ServerWebExchange exchange) { Route route = exchange.getRequiredAttribute(GATEWAY_ROUTE_ATTR); List\u0026amp;lt;GatewayFilter\u0026amp;gt; gatewayFilters = route.getFilters(); List\u0026amp;lt;GatewayFilter\u0026amp;gt; combined = new ArrayList\u0026amp;lt;\u0026amp;gt;(this.globalFilters); combined.addAll(gatewayFilters); //TODO: needed or cached? AnnotationAwareOrderComparator.sort(combined); logger.debug(\u0026amp;quot;Sorted gatewayFilterFactories: \u0026amp;quot;+ combined); return new DefaultGatewayFilterChain(combined).filter(exchange); }  2.4 执行Filter链 private static class DefaultGatewayFilterChain …","date":1521288000,"description":"本篇文章主要从源码的角度揭秘Spring Cloud Gateway的怎么处理请求流程。","dir":"blog/scg-08/","fuzzywordcount":1400,"kind":"page","lang":"zh","lastmod":1521288000,"objectID":"e4fe27d91a1a644302436dd065d99463","permalink":"/blog/scg-08/","publishdate":"2018-03-17T20:00:00+08:00","readingtime":3,"relpermalink":"/blog/scg-08/","summary":"1.Spring Gateway概述 Spring Cloud Gateway是Spring官方基于Spring 5.0，Spring Boot 2.0和Project Reactor等技术开发","tags":["Spring Cloud Gateway"],"title":"Spring Cloud Gateway揭秘之处理请求流程","type":"blog","url":"/blog/scg-08/","wordcount":1382},{"author":"许进","categories":"Spring Cloud Gateway","content":" 1.Spring Gateway概述 1.1 什么是Spring Cloud Gateway Spring Cloud Gateway是Spring官方基于Spring 5.0，Spring Boot 2.0和Project Reactor等技术开发的网关，Spring Cloud Gateway旨在为微服务架构提供一种简单而有效的统一的API路由管理方式。Spring Cloud Gateway作为Spring Cloud生态系中的网关，目标是替代Netflix ZUUL，其不仅提供统一的路由方式，并且基于Filter链的方式提供了网关基本的功能，例如：安全，监控/埋点，和限流等。\n2. Spring Cloud Gateway入门案例 2.1 创建maven工程 配置Spring Cloud Gateway的相关Maven依赖\n\u0026amp;lt;project xmlns=\u0026amp;quot;http://maven.apache.org/POM/4.0.0\u0026amp;quot; xmlns:xsi=\u0026amp;quot;http://www.w3.org/2001/XMLSchema-instance\u0026amp;quot; xsi:schemaLocation=\u0026amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;parent\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;ch18-1\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;cn.springcloud.book\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;1.0-SNAPSHOT\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/parent\u0026amp;gt; \u0026amp;lt;modelVersion\u0026amp;gt;4.0.0\u0026amp;lt;/modelVersion\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;ch18-1-gateway\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;packaging\u0026amp;gt;jar\u0026amp;lt;/packaging\u0026amp;gt; \u0026amp;lt;name\u0026amp;gt;ch18-1-gateway\u0026amp;lt;/name\u0026amp;gt; \u0026amp;lt;url\u0026amp;gt;http://springcloud.cn\u0026amp;lt;/url\u0026amp;gt; \u0026amp;lt;properties\u0026amp;gt; \u0026amp;lt;spring-cloud.version\u0026amp;gt;Finchley.M8\u0026amp;lt;/spring-cloud.version\u0026amp;gt; \u0026amp;lt;/properties\u0026amp;gt; \u0026amp;lt;dependencyManagement\u0026amp;gt; \u0026amp;lt;dependencies\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-dependencies\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${spring-cloud.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;type\u0026amp;gt;pom\u0026amp;lt;/type\u0026amp;gt; \u0026amp;lt;scope\u0026amp;gt;import\u0026amp;lt;/scope\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;/dependencies\u0026amp;gt; \u0026amp;lt;/dependencyManagement\u0026amp;gt; \u0026amp;lt;dependencies\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-actuator\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-gateway\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;/dependencies\u0026amp;gt; \u0026amp;lt;build\u0026amp;gt; \u0026amp;lt;plugins\u0026amp;gt; \u0026amp;lt;plugin\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-maven-plugin\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/plugin\u0026amp;gt; \u0026amp;lt;/plugins\u0026amp;gt; \u0026amp;lt;/build\u0026amp;gt; \u0026amp;lt;repositories\u0026amp;gt; \u0026amp;lt;repository\u0026amp;gt; \u0026amp;lt;id\u0026amp;gt;spring-snapshots\u0026amp;lt;/id\u0026amp;gt; \u0026amp;lt;name\u0026amp;gt;Spring Snapshots\u0026amp;lt;/name\u0026amp;gt; \u0026amp;lt;url\u0026amp;gt;https://repo.spring.io/snapshot\u0026amp;lt;/url\u0026amp;gt; \u0026amp;lt;snapshots\u0026amp;gt; \u0026amp;lt;enabled\u0026amp;gt;true\u0026amp;lt;/enabled\u0026amp;gt; \u0026amp;lt;/snapshots\u0026amp;gt; \u0026amp;lt;/repository\u0026amp;gt; \u0026amp;lt;repository\u0026amp;gt; \u0026amp;lt;id\u0026amp;gt;spring-milestones\u0026amp;lt;/id\u0026amp;gt; \u0026amp;lt;name\u0026amp;gt;Spring Milestones\u0026amp;lt;/name\u0026amp;gt; \u0026amp;lt;url\u0026amp;gt;https://repo.spring.io/milestone\u0026amp;lt;/url\u0026amp;gt; \u0026amp;lt;snapshots\u0026amp;gt; \u0026amp;lt;enabled\u0026amp;gt;false\u0026amp;lt;/enabled\u0026amp;gt; \u0026amp;lt;/snapshots\u0026amp;gt; \u0026amp;lt;/repository\u0026amp;gt; \u0026amp;lt;/repositories\u0026amp;gt; \u0026amp;lt;pluginRepositories\u0026amp;gt; \u0026amp;lt;pluginRepository\u0026amp;gt; \u0026amp;lt;id\u0026amp;gt;spring-snapshots\u0026amp;lt;/id\u0026amp;gt; \u0026amp;lt;name\u0026amp;gt;Spring Snapshots\u0026amp;lt;/name\u0026amp;gt; \u0026amp;lt;url\u0026amp;gt;https://repo.spring.io/snapshot\u0026amp;lt;/url\u0026amp;gt; \u0026amp;lt;snapshots\u0026amp;gt; \u0026amp;lt;enabled\u0026amp;gt;true\u0026amp;lt;/enabled\u0026amp;gt; \u0026amp;lt;/snapshots\u0026amp;gt; \u0026amp;lt;/pluginRepository\u0026amp;gt; \u0026amp;lt;pluginRepository\u0026amp;gt; \u0026amp;lt;id\u0026amp;gt;spring-milestones\u0026amp;lt;/id\u0026amp;gt; \u0026amp;lt;name\u0026amp;gt;Spring …","date":1521093600,"description":"本篇文章主要介绍了什么是Spring Cloud Gateway，并基于Spring Cloud Gateway的Finchley.M8版本编写一个Spring Cloud Gateway的入门案例，即基本代理的路由转发配置","dir":"blog/scg-01/","fuzzywordcount":900,"kind":"page","lang":"zh","lastmod":1521093600,"objectID":"b76a13a9b901ee406e7fcec849fd87b7","permalink":"/blog/scg-01/","publishdate":"2018-03-15T14:00:00+08:00","readingtime":2,"relpermalink":"/blog/scg-01/","summary":"1.Spring Gateway概述 1.1 什么是Spring Cloud Gateway Spring Cloud Gateway是Spring官方基于Spring 5.0，Spring Boot 2.0和Project","tags":["Spring Cloud Gateway"],"title":"Spring Cloud Gateway入门案例","type":"blog","url":"/blog/scg-01/","wordcount":877},{"author":"许进","categories":"并发编程","content":" 1. 同步类容器 同步类容器都是线程安全的，但在某些场景下可能需要加锁来保护复合操作。 复合操作如： * 迭代(反复访问元素，遍历容器中所有的元素)， * 跳转（根据指定的顺序找到当前元素的下一个元素），以及条件运算。\n 这些复合操作在多线并发地修改容器时，可能会表现出意外的行为，最经典的便是ConcurrentModificationException，原因是当容器迭代的过程中，被并发的修改了内容，这是由于早期迭代器设计的时候并没有考虑并发修改的问题。\n public class Tickets { public static void main(String[] args) { //初始化火车票池并添加火车票:避免线程同步可采用Vector替代ArrayList HashTable替代HashMap final Vector\u0026amp;lt;String\u0026amp;gt; tickets = new Vector\u0026amp;lt;String\u0026amp;gt;(); for (int i = 1; i \u0026amp;lt;= 1000; i++) { tickets.add(\u0026amp;quot;火车票\u0026amp;quot; + i); } for (Iterator iterator = tickets.iterator(); iterator.hasNext(); ) { String string = (String) iterator.next(); tickets.remove(20); } } }  运行出现，如下错误:\nException in thread \u0026amp;quot;main\u0026amp;quot; java.util.ConcurrentModificationException at java.util.Vector$Itr.checkForComodification(Vector.java:1184) at java.util.Vector$Itr.next(Vector.java:1137) at org.xujin.janus.poc.server.Tickets.main(Tickets.java:35)  1.2 同步类容器:如古老的Vector，HashTable。这些容器的同步功能其实都是由jdk的Collections.synchronized*** 比如:Collections.synchronizedMap等工厂方法去创建实现的。比如,如下：\nMap\u0026amp;lt;String, String\u0026amp;gt; map = Collections.synchronizedMap(new HashMap\u0026amp;lt;String, String\u0026amp;gt;());   本身hashMap不是线程安全的，但是Collections.synchronizedMap(new HashMap())工厂方法包裹之后，就变成线程安全的。\n 其底层的机制无非就是传统的synchronized关键字对每个公用的方法都进行同步，使得每次只能有一个线程访问容器的状态。这很明显不满足我们今天互联网时代高并发的需求，在保证线程安全的同时，也必须要有足够好的性能。\npublic class Tickets { public static void main(String[] args) { final Vector\u0026amp;lt;String\u0026amp;gt; tickets = new Vector\u0026amp;lt;String\u0026amp;gt;(); for (int i = 1; i \u0026amp;lt;= 1000; i++) { tickets.add(\u0026amp;quot;火车票\u0026amp;quot; + i); } for (int i = 1; i \u0026amp;lt;= 10; i++) { new Thread(\u0026amp;quot;线程\u0026amp;quot; + i) { public void run() { while (true) { if (tickets.isEmpty()) break; System.out.println(Thread.currentThread().getName() + \u0026amp;quot;---\u0026amp;quot; + tickets.remove(0)); } } }.start(); } } }   Ps:在实际开发中，尽量使用并发类容器替代同步类容器。\n 2. 并发类容器 2.1 并发类容器概述 jdk5.0之后提供了多种并发类容器来替代同步类容器从而改善性能。同步类容器的状态都是串行化的，他们虽然实现了线程安全，但是严重降低了并发性，在多线程环境时，严重降低了应用程序的吞吐量。 并发类容器是专门针对并发设计的，使用ConcurrentHashMap来替代给予散列的传统hashTable，而且在ConcurrentHashMap中，添加了一些常见复合操作的支持。以及使用了CopyOnWriteArrayList代替Voctor，并发的CopOnwriteArraySet，以及并发的Queue，ConcurrentLinkedQueue和LinkedBlockingQueue，前者是高性能的队列，后者是以阻塞形式的队列，具体实现Queue还有很多，例如ArrayBlockQueue，PriorityBlockingQueue，SynchronousQueue等。\n2.3 ConcurrentMap ConcurrentMap接口下有两个重要的实现: ConcurrentHashMap,ConcurrentSkipListMap(支持并发排序功能，弥补ConcurrentHashMap)\nConcurrentHashMap内部使用分段锁(segment)来标识这些不同的部门，在每个段其实就是一个小的hashTable，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就是可以并发进行。把一个整体划分成了16个段(segment)。也就是最高支持16个线程的并发修改操作，这也是在多线程场景时减小锁的粒度从而减低锁竞争的一种方案。并且代码中大多共享变量使用volatile关键字声明，目的是第一时间获取修改的内容，性能非常好。\n ConcurrentHashMap最高支持分16个段。\n 2.4 Copy-On-Write容器  未完待续。。。。。\n ","date":1507035600,"description":"并发编程总结之同类容器和异步容器","dir":"blog/bf/bf01/","fuzzywordcount":1600,"kind":"page","lang":"zh","lastmod":1507035600,"objectID":"c8e03134d6aa3e1cbd81afa1e8a8e7cf","permalink":"/blog/bf/bf01/","publishdate":"2017-10-03T21:00:00+08:00","readingtime":4,"relpermalink":"/blog/bf/bf01/","summary":"1. 同步类容器 同步类容器都是线程安全的，但在某些场景下可能需要加锁来保护复合操作。 复合操作如： * 迭代(反复访问元素，遍历容器中所有的元素)， *","tags":["并发编程","多线程"],"title":"并发编程总结之同类容器和异步容器","type":"blog","url":"/blog/bf/bf01/","wordcount":1597},{"author":"许进","categories":"Spring Boot","content":" 1.通过AOP 自定义注解实现主库到备库的切换 1.1 自定义注解 自定义注解如下代码所示\nimport java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) public @interface SwitchDataBase { boolean switch2Backup() default false; }  1.2 实现方法拦截器对自定义注解处理 import java.lang.reflect.Method; import java.util.Arrays; import org.aopalliance.intercept.MethodInterceptor; import org.aopalliance.intercept.MethodInvocation; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.stereotype.Component; /** * 处理走备库逻辑的注解 */ @Component public class SwitchDataBaseInterceptor implements MethodInterceptor { private final Logger log = LoggerFactory.getLogger(SwitchDataBaseInterceptor.class); @Override public Object invoke(MethodInvocation invocation) throws Throwable { Method method = invocation.getMethod(); SwitchDataBase annotation = getAnnotation(method); if (annotation == null) { return invocation.proceed(); } Object val = null; if(!ThreadLocalMap.containsKey(GroupDataSourceRouteHelper.DATASOURCE_INDEX)) { if (annotation.switch2Backup()) { log.info(\u0026amp;quot;query back up DB, method: \u0026amp;quot; + method.getName()); GroupDataSourceRouteHelper.executeByGroupDataSourceIndex(1, true); } else { log.info(\u0026amp;quot;query primary DB, method: \u0026amp;quot; + method.getName()); GroupDataSourceRouteHelper.executeByGroupDataSourceIndex(0, true); } } try { val = invocation.proceed(); } catch (Exception e) { log.info(method.getDeclaringClass().getName() + \u0026amp;quot;.\u0026amp;quot; + invocation.getMethod().getName() + \u0026amp;quot;方法调用失败，arguments：\u0026amp;quot; + Arrays.toString(invocation.getArguments())); throw new RuntimeException(e); } finally { GroupDataSourceRouteHelper.removeGroupDataSourceIndex(); } return val; } /** * 找方法上面声明的注解 */ private SwitchDataBase getAnnotation(Method method) { if (method.isAnnotationPresent(SwitchDataBase.class)) { return method.getAnnotation(SwitchDataBase.class); } return null; } }  1.3 配置OverallQueryConfiguration 在Spring Boot中装配AOP Bean，实现扫描特定目录下的注解，实现切面变成形成通知处理。示例代码如下\npackage com.wdk.wms.configuration; import com.wdk.wms.annotation.SwitchDataBaseInterceptor; import org.springframework.aop.Advisor; import org.springframework.aop.support.DefaultPointcutAdvisor; import org.springframework.aop.support.JdkRegexpMethodPointcut; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class SwitchDataBaseConfiguration { @Bean(name = \u0026amp;quot;overallQueryInterceptor\u0026amp;quot;) public SwitchDataBaseInterceptor overallQueryInterceptor() { return new SwitchDataBaseInterceptor(); } //添加aop的pointcut @Bean(name = \u0026amp;quot;jdkRegexpMethodPointcut\u0026amp;quot;) public JdkRegexpMethodPointcut jdkRegexpMethodPointcut() { JdkRegexpMethodPointcut jdkRegexpMethodPointcut = new JdkRegexpMethodPointcut(); jdkRegexpMethodPointcut.setPatterns(\u0026amp;quot;com.wdk.wms.mapper.*\u0026amp;quot;); return jdkRegexpMethodPointcut; } …","date":1506405600,"description":"本篇文章的场景是做调度中心和监控中心时的需求，后端使用TDDL实现分表分库，需求:实现关键业务的查询监控,当用Mybatis查询数据时需要从主库切换到备库或者直接连到备库上查询,从而减小主库的压力，在本篇文章中主要记录在Spring Boot中通过自定义注解结合AOP实现直接连接备库查询。","dir":"blog/sb/sb-aop/","fuzzywordcount":500,"kind":"page","lang":"zh","lastmod":1506405600,"objectID":"addb7f1d67b44f20f9512df94e402455","permalink":"/blog/sb/sb-aop/","publishdate":"2017-09-26T14:00:00+08:00","readingtime":1,"relpermalink":"/blog/sb/sb-aop/","summary":"1.通过AOP 自定义注解实现主库到备库的切换 1.1 自定义注解 自定义注解如下代码所示 import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) public @interface SwitchDataBase { boolean switch2Backup() default false; } 1.2 实现方法拦截器对自定义","tags":["项目经验"],"title":"Spring Boot中自定义注解+AOP实现主备库切换","type":"blog","url":"/blog/sb/sb-aop/","wordcount":478},{"author":"许进","categories":"并发编程","content":" 一.ThreadLocal的概念 1.1 ThreadLocal概念 ThreadLocal概念：线程局部变量，是一种多线程间并发访问变量的解决方案。与其synchronized等加锁的方式不同，ThreadLocal完全不提供锁，而使用以空间换时间的手段，为每个线程提供变量的独立副本，以保障线程安全。\n从性能上说，ThreadLocal不具有绝对的优势，在并发不是很高的时候，加锁的性能会更好，但作为一套与锁完全无关的线程安全解决方案，在高并发量或者竞争激烈的场景，使用ThreadLocal可以在一定程度上减少锁竞争。\n ThreadLocal多线程间并发访问变量的解决方案，为每个线程提供变量的副本，用空间换时间。 因为ThreadLocal在每个线程中对该变量会创建一个副本，即每个线程内部都会有一个该变量，且在线程内部任何地方都可以使用，线程之间互不影响，这样一来就不存在线程安全问题，也不会严重影响程序执行性能。\n  虽然ThreadLocal能够解决上面说的问题，但是由于在每个线程中都创建了副本，所以要考虑它对资源的消耗，比如内存的占用会比不使用ThreadLocal要大。\n 1.2 ThreadLocal代码示例 package org.xujin.bf; public class ConnThreadLocal { //用ThreadLocal去存储多线程下访问的变量 public static ThreadLocal\u0026amp;lt;String\u0026amp;gt; th = new ThreadLocal\u0026amp;lt;String\u0026amp;gt;(); public void setTh(String value){ th.set(value); } public void getTh(){ System.out.println(Thread.currentThread().getName() + \u0026amp;quot;:\u0026amp;quot; + this.th.get()); } public static void main(String[] args) throws InterruptedException { final ConnThreadLocal ct = new ConnThreadLocal(); Thread t1 = new Thread(new Runnable() { @Override public void run() { ct.setTh(\u0026amp;quot;张三\u0026amp;quot;); ct.getTh(); } }, \u0026amp;quot;t1\u0026amp;quot;); Thread t2 = new Thread(new Runnable() { @Override public void run() { try { Thread.sleep(1000); ct.setTh(\u0026amp;quot;李四\u0026amp;quot;); ct.getTh(); } catch (InterruptedException e) { e.printStackTrace(); } } }, \u0026amp;quot;t2\u0026amp;quot;); t1.start(); t2.start(); } }  执行结果如下:\nt1:张三 t2:李四  如上述代码所示，如果把ct.setTh(\u0026amp;ldquo;李四\u0026amp;rdquo;)注释，执行结果如下：\nt1:张三 t2:null   PS:两个线程之前都使用了ThreadLocal包装的变量th，但是Threadlocal两个线程之间数据独立，因此t1,t2两个线程之间数据访问隔离了。\n 二.单例与多线程 什么是单例? 单例是应用或者系统中保证一个类仅有一个实例，并提供一个访问它的全局访问点。\n单例模式，最常见的就是饥饿模式和懒汉模式，一个直接实例化对象，一个是在调用方法时进行实例化对象。在多线程模式中，考虑到性能和线程安全，我们一般选择下面两种比较经典的单例模式，在性能提高的同时，又保证线程安全。\n单例推荐的写法有dubble check instance，static inner class(静态内部类的模式)，因为简单安全，源生就支持多线程，对多线程比较友好，因此推荐静态内部的写法。\n2.1 饿汉模式 这种方法非常简单，因为单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。\npublic class Singleton{ //类加载时就初始化 private static final Singleton instance = new Singleton(); private Singleton(){} public static Singleton getInstance(){ return instance; } }  这种写法如果完美的话，就没必要在啰嗦那么多双检锁的问题了。缺点是它不是一种懒加载模式（lazy initialization），单例会在加载类后一开始就被初始化，即使客户端没有调用 getInstance()方法。饿汉式的创建方式在一些场景中将无法使用：譬如 Singleton 实例的创建是依赖参数或者配置文件的，在 getInstance() 之前必须调用某个方法设置参数给它，那样这种单例写法就无法使用了。\n2.2 枚举写法 用枚举写单例实在太简单了！这也是它最大的优点。下面这段代码就是声明枚举实例的通常做法。\npublic enum EasySingleton{ INSTANCE; }   可以通过EasySingleton.INSTANCE来访问实例，这比调用getInstance()方法简单多了。创建枚举默认就是线程安全的，所以不需要担心double checked locking，而且还能防止反序列化导致重新创建新的对象。\n 2.3 懒汉式，线程不安全 public class Singleton { private static Singleton instance; private Singleton (){} public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } }   这段代码简单明了，而且使用了懒加载模式，但是却存在致命的问题。当有多个线程并行调用 getInstance() 的时候，就会创建多个实例。也就是说在多线程下不能正常工作。\n 2.4 懒汉式，线程安全 为了解决上面的问题，最简单的方法是将整个 getInstance() 方法设为同步（synchronized）。\npublic static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; }   虽然做到了线程安全，并且解决了多实例的问题，但是它并不高效。因为在任何时候只能有一个线程调用 getInstance() 方法。但是同步操 …","date":1503838800,"description":"本文结合最近网关项目代码重构，总结介绍了`ThreadLocal`是一种`多线程间并发访问变量`的解决方案，用空间换时间，并用代码示例说明，还介绍了什么是单例以及单例的推荐两种写法分别是`静态内部类`写法和`dubbl check instance`的写法，扩展介绍了其它懒汉，枚举,饿汉的写法等","dir":"blog/bf/bf-th-sing/","fuzzywordcount":3600,"kind":"page","lang":"zh","lastmod":1503838800,"objectID":"1b99df095ac45fbdf5da8556f8aae1a1","permalink":"/blog/bf/bf-th-sing/","publishdate":"2017-08-27T21:00:00+08:00","readingtime":8,"relpermalink":"/blog/bf/bf-th-sing/","summary":"一.ThreadLocal的概念 1.1 ThreadLocal概念 ThreadLocal概念：线程局部变量，是一种多线程间并发访问变量的解决方案。","tags":["并发编程","多线程"],"title":"并发编程之ThreadLocal与单例的推荐写法","type":"blog","url":"/blog/bf/bf-th-sing/","wordcount":3528},{"author":"许进","categories":"Mybatis","content":" 1. mybatis-gennerator 1.1 mybatis-gennerator自动生成代码 1.1.1 mybatis-gennerator的安装 Mybatis-Generator的下载地址:https://github.com/mybatis/generator/releases\n 在Eclipse安装mybatis-gennerator插件。   https://marketplace.eclipse.org/content/mybatis-generator\n 2.在项目中安装Maven插件\n\u0026amp;lt;build\u0026amp;gt; \u0026amp;lt;finalName\u0026amp;gt;janus-admin\u0026amp;lt;/finalName\u0026amp;gt; \u0026amp;lt;pluginManagement\u0026amp;gt; \u0026amp;lt;plugins\u0026amp;gt; \u0026amp;lt;plugin\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.maven.plugins\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;maven-compiler-plugin\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;configuration\u0026amp;gt; \u0026amp;lt;source\u0026amp;gt;1.8\u0026amp;lt;/source\u0026amp;gt; \u0026amp;lt;target\u0026amp;gt;1.8\u0026amp;lt;/target\u0026amp;gt; \u0026amp;lt;/configuration\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;3.3\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/plugin\u0026amp;gt; \u0026amp;lt;plugin\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.mybatis.generator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;mybatis-generator-maven-plugin\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;1.3.2\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;dependencies\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;mysql\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;mysql-connector-java\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;6.0.6\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;/dependencies\u0026amp;gt; \u0026amp;lt;configuration\u0026amp;gt; \u0026amp;lt;!--配置文件的路径 --\u0026amp;gt; \u0026amp;lt;configurationFile\u0026amp;gt;${basedir}/generatorConfig.xml\u0026amp;lt;/configurationFile\u0026amp;gt; \u0026amp;lt;overwrite\u0026amp;gt;true\u0026amp;lt;/overwrite\u0026amp;gt; \u0026amp;lt;/configuration\u0026amp;gt; \u0026amp;lt;/plugin\u0026amp;gt; \u0026amp;lt;/plugins\u0026amp;gt; \u0026amp;lt;/pluginManagement\u0026amp;gt; \u0026amp;lt;/build\u0026amp;gt;  使用命令:mybatis-generator:generate生成\n 推荐安装IDE插件的方式或者Maven插件的方式，生成的代码直接刷新工程即可\n generatorConfig.xml示例\n\u0026amp;lt;?xml version=\u0026amp;quot;1.0\u0026amp;quot; encoding=\u0026amp;quot;UTF-8\u0026amp;quot; ?\u0026amp;gt; \u0026amp;lt;!DOCTYPE generatorConfiguration PUBLIC \u0026amp;quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\u0026amp;quot; \u0026amp;quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\u0026amp;quot; \u0026amp;gt; \u0026amp;lt;generatorConfiguration\u0026amp;gt; \u0026amp;lt;!-- 数据库驱动包位置 --\u0026amp;gt; \u0026amp;lt;classPathEntry location=\u0026amp;quot;D:\\develop\\apache-maven-3.5.0\\res\\mysql\\mysql-connector-java\\5.1.35\\mysql-connector-java-5.1.35.jar\u0026amp;quot; /\u0026amp;gt; \u0026amp;lt;context id=\u0026amp;quot;context1\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;commentGenerator\u0026amp;gt; \u0026amp;lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;suppressAllComments\u0026amp;quot; value=\u0026amp;quot;true\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;/commentGenerator\u0026amp;gt; \u0026amp;lt;!-- 数据库链接URL、用户名、密码 --\u0026amp;gt; \u0026amp;lt;jdbcConnection driverClass=\u0026amp;quot;com.mysql.jdbc.Driver\u0026amp;quot; connectionURL=\u0026amp;quot;jdbc:mysql://主机:3306/数据库\u0026amp;quot; userId=\u0026amp;quot;用户名\u0026amp;quot; password=\u0026amp;quot;密码\u0026amp;quot; /\u0026amp;gt; \u0026amp;lt;!-- 生成模型的包名和位置 --\u0026amp;gt; \u0026amp;lt;javaModelGenerator targetPackage=\u0026amp;quot;org.xujin.janus.admin.entity\u0026amp;quot; targetProject=\u0026amp;quot;janus-admin/src/main/java\u0026amp;quot; /\u0026amp;gt; \u0026amp;lt;!-- 生成的映射文件报名和位置 --\u0026amp;gt; \u0026amp;lt;sqlMapGenerator targetPackage=\u0026amp;quot;mapper\u0026amp;quot; targetProject=\u0026amp;quot;janus-admin/src/main/resources\u0026amp;quot; /\u0026amp;gt; \u0026amp;lt;!-- 生成DAO的包名和位置 --\u0026amp;gt; \u0026amp;lt;javaClientGenerator targetPackage=\u0026amp;quot;org.xujin.janus.admin.mapper\u0026amp;quot; targetProject=\u0026amp;quot;janus-admin/src/main/java\u0026amp;quot; type=\u0026amp;quot;XMLMAPPER\u0026amp;quot; /\u0026amp;gt; \u0026amp;lt;!-- 要生成的那些表(更改tableName 和domainObjectName 就可以了) --\u0026amp;gt; \u0026amp;lt;table schema=\u0026amp;quot;janus_admin\u0026amp;quot; tableName=\u0026amp;quot;cluster\u0026amp;quot; domainObjectName=\u0026amp;quot;Cluster\u0026amp;quot; enableCountByExample=\u0026amp;quot;false\u0026amp;quot; …","date":1503640800,"description":"本篇文章主要介绍使用mybatis-gennerator快速生成代码，但是每次生成的Mapper或接口都会覆盖自定义的Mapper，因此介绍了Mapper接口的继承方式解决，还介绍了如何使用分页工具使用pagehelper结合Mybatis快速实现分页","dir":"blog/mybatis/1/","fuzzywordcount":1200,"kind":"page","lang":"zh","lastmod":1503640800,"objectID":"af948ff371844eda153a7f34137562c8","permalink":"/blog/mybatis/1/","publishdate":"2017-08-25T14:00:00+08:00","readingtime":3,"relpermalink":"/blog/mybatis/1/","summary":"1. mybatis-gennerator 1.1 mybatis-gennerator自动生成代码 1.1.1 mybatis-gennerator的安装 Mybatis-Generator的下载地","tags":["Myabtis","项目经验"],"title":"Mybatis代码生成+分页+Mapper继承扩展","type":"blog","url":"/blog/mybatis/1/","wordcount":1176},{"author":"许进","categories":"并发编程","content":" 1. volatile概念  在java中，每个线程都会有一块工作内存区，其中存放着所有线程共享的主内存中的变量值的拷贝。当线程执行时，它在自己的工作区内存中操作这些变量。为了存取一个共享的变量，一个线程通常会先获取锁定并清除它的内存工作区，把这些共享变量从所有线程的共享内存中正确的装入到它自己所在的工作内存中，当线程解锁时，保证该工作内存中变量的值写回到共享内存中。\n volatile的作用就是强制线程到主内存(共享内存)里去读取变量，而不去线程工作区内存里去读取，从而实现了多个线程间的变量可见，也就是满足线程安全的可见性。\n  2 volatile概念-具有可见性 volatile关键字的作用是使变量在多个线程间可见。\n2.1 代码示例 如下代码所示，当isRunning没有被volatile关键字修饰的时候，程序一直循环，线程不会结束。\npublic class RunThread extends Thread { // isRunning没有被volatile关键字修饰 private boolean isRunning = true;//① private void setRunning(boolean isRunning) { this.isRunning = isRunning; } public void run() { System.out.println(\u0026amp;quot;开始进入run方法..\u0026amp;quot;); while (isRunning == true) { // 一直循环........ } System.out.println(\u0026amp;quot;while循环结束,线程停止\u0026amp;quot;); } public static void main(String[] args) throws InterruptedException { RunThread rt = new RunThread(); rt.start(); Thread.sleep(3000); rt.setRunning(false); System.out.println(\u0026amp;quot;isRunning的值已经被设置了false\u0026amp;quot;); Thread.sleep(1000); System.out.println(rt.isRunning); } }  当把上述代码的①处，修改为如下时:\nprivate volatile boolean isRunning = true;  运行结果是isRunning修改为false之后，线程读取到isRunning = false，从而线程结束while循环，线程退出\n开始进入run方法.. isRunning的值已经被设置了false while循环结束,线程停止 false  ###示例代码线程操作内存简图 2.2 小结  在java中，每个线程都会有一块工作内存区，其中存放着所有线程共享的主内存中的变量值得拷贝。当线程执行时，它在自己的工作区内存中操作这些变量。为了存取一个共享的变量，一个线程通常会先获取锁定并清除它的内存工作区，把这些共享变量从所有线程的共享内存中正确的装入到它自己所在的工作内存中，当线程解锁时，保证该工作内存中变量的值写回到共享内存中。 一个线程可以执行的操作有使用(use)，赋值(assign),装载(load),存储(store),锁定(lock),解锁(unlock)。而主内存可以执行的操作有读(read),写(write),锁定(lock),解锁（unlock)，每个操作都是原子的。 volatile的作用就是强制线程到主内存(共享内存)里去读取变量，而不去线程工作区内存里去读取，从而实现了多个线程间的变量可见，也就是满足线程安全的可见性。  3.volatile-不具有原子性 volatile关键字虽然拥有多个线程之间的可见性，但是不具备同步性，也就是原子性，可以算得上一个轻量级别的synchronized,性能要比synchronized强很多，不会造成阻塞(在很多开源框架，比如Netty的底层代码就大量的使用volatile，由此可见Netty的性能非常不错),但是需要注意的是，volatile用于只针对于多个线程可见的变量操作，并不能替代synchronized的同步功能。\n3.1 示例代码1 public class VolatileNoAtomic extends Thread { private static volatile int count; private static void addCount() { for (int i = 0; i \u0026amp;lt; 1000; i++) { count++; } System.out.println(count); } public void run() { addCount(); } public static void main(String[] args) { VolatileNoAtomic[] arr = new VolatileNoAtomic[100]; for (int i = 0; i \u0026amp;lt; 10; i++) { arr[i] = new VolatileNoAtomic(); } for (int i = 0; i \u0026amp;lt; 10; i++) { arr[i].start(); } } }  运行结果，随机因为volatile没有原子性，所以最终打印结果不是10000\n3.2 示例代码2 public class VolatileNoAtomic extends Thread { private static AtomicInteger count = new AtomicInteger(0); private static void addCount() { for (int i = 0; i \u0026amp;lt; 1000; i++) { count.incrementAndGet(); } System.out.println(count); } public void run() { addCount(); } public static void main(String[] args) { VolatileNoAtomic[] arr = new VolatileNoAtomic[100]; for (int i = 0; i \u0026amp;lt; 10; i++) { arr[i] = new VolatileNoAtomic(); } for (int i = 0; i \u0026amp;lt; 10; i++) { arr[i].start(); } } }  运行最终打印结果是:10000\n 小结:volatile关键字只有可见性，没有原子性。要实现原子性建议使用atomic类的系列对象，支持原子性操作。\n 注意atomic类只保证本身方法的原子性，并不保证多次操作的原子性。\npackage org.xujin.multithread.sync007; import java.util.ArrayList; import java.util.List; import …","date":1470747600,"description":"本文主要介绍了 volatile关键字的作用是使变量在多个线程间可见,但是不具有原子性，以及volatile的运行内存介绍","dir":"blog/bf/bf-volatile/","fuzzywordcount":1900,"kind":"page","lang":"zh","lastmod":1470747600,"objectID":"55126bc6a0bcbe0b333b1bd20999aef3","permalink":"/blog/bf/bf-volatile/","publishdate":"2016-08-09T21:00:00+08:00","readingtime":4,"relpermalink":"/blog/bf/bf-volatile/","summary":"1. volatile概念 在java中，每个线程都会有一块工作内存区，其中存放着所有线程共享的主内存中的变量值的拷贝。当线程执行时，它在自己的工","tags":["并发编程","多线程"],"title":"并发编程总结之volatile","type":"blog","url":"/blog/bf/bf-volatile/","wordcount":1860},{"author":"许进","categories":"并发编程","content":" 1. 线程间通信概念 线程是操作系统中独立的个体，但这些个体如果不经过特殊的处理就不能成为一个整体，线程间的通信就成为整体的必用方式之一。当线程存在通信指挥，系统间的交互会更加强大，在提高CPU利用率的同时还会使开发人员对线程任务在处理的过程中进行有效的把控与监督。\n2. wait/notify实现线程通信 使用wait/notify方法实现线程间的通信。注意这两个方法都是Object的类方法，换句话说Java为所有的对象提供了这个两个方法。 1.wait和notify必须配合synchronized关键字使用 2.wait方法释放锁，notify方法不释放锁。\n2.1最原始线程间通信代码 如下面代码所示，t1,t2两个线程，t1线程一直循环add，t2线程一直循环，当t1线程把list的size变为5的时候，t2线程抛出异常停止。\nimport java.util.ArrayList; import java.util.List; /** * * @author xujin * */ public class ListAdd1 { private volatile static List\u0026amp;lt;String\u0026amp;gt; list = new ArrayList(); public void add() { list.add(\u0026amp;quot;test....\u0026amp;quot;); } public int size() { return list.size(); } public static void main(String[] args) { final ListAdd1 list1 = new ListAdd1(); Thread t1 = new Thread(new Runnable() { @Override public void run() { try { for (int i = 0; i \u0026amp;lt; 10; i++) { list1.add(); System.out .println(\u0026amp;quot;当前线程：\u0026amp;quot; + Thread.currentThread().getName() + \u0026amp;quot;添加了一个元素..\u0026amp;quot;); Thread.sleep(500); } } catch (InterruptedException e) { e.printStackTrace(); } } }, \u0026amp;quot;t1\u0026amp;quot;); Thread t2 = new Thread(new Runnable() { @Override public void run() { while (true) { if (list1.size() == 5) { System.out.println(\u0026amp;quot;当前线程收到通知：\u0026amp;quot; + Thread.currentThread().getName() + \u0026amp;quot; list size = 5 线程停止..\u0026amp;quot;); throw new RuntimeException(); } } } }, \u0026amp;quot;t2\u0026amp;quot;); t1.start(); t2.start(); } }  2.2 wait和notify实现线程间通信代码 import java.util.ArrayList; import java.util.List; /** * @author xujin * */ public class ListAdd2 { private volatile static List list = new ArrayList(); public void add() { list.add(\u0026amp;quot;test.......\u0026amp;quot;); } public int size() { return list.size(); } public static void main(String[] args) { final ListAdd2 list2 = new ListAdd2(); final Object lock = new Object(); Thread t1 = new Thread(new Runnable() { @Override public void run() { try { synchronized (lock) { System.out.println(\u0026amp;quot;t1启动..\u0026amp;quot;); for (int i = 0; i \u0026amp;lt; 10; i++) { list2.add(); System.out.println( \u0026amp;quot;当前线程：\u0026amp;quot; + Thread.currentThread().getName() + \u0026amp;quot;添加了一个元素..\u0026amp;quot;); Thread.sleep(500); if (list2.size() == 5) { System.out.println(\u0026amp;quot;已经发出通知..\u0026amp;quot;); lock.notify(); } } } } catch (InterruptedException e) { e.printStackTrace(); } } }, \u0026amp;quot;t1\u0026amp;quot;); Thread t2 = new Thread(new Runnable() { @Override public void run() { synchronized (lock) { System.out.println(\u0026amp;quot;t2启动..\u0026amp;quot;); if (list2.size() != 5) { try { //t2线程，拿到了锁，但是size不等于5,所以lock.wait(),释放了锁，然后t1得到t2释放的锁。 System.out.println(\u0026amp;quot;size() != 5,t2 wait释放锁！..\u0026amp;quot;); lock.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(\u0026amp;quot;当前线程：\u0026amp;quot; + Thread.currentThread().getName() + \u0026amp;quot;收到通知线程停止..\u0026amp;quot;); throw new RuntimeException(); } } }, \u0026amp;quot;t2\u0026amp;quot;); t1.start(); t2.start(); } }  运行结果分析如下:  通过上面的运行结果分析，可以看出线程间的通信，因为持有锁的问题，使用wait、notify线程间通信，没法做到实时通信。\n 2.3 使用java.util.concurrent下的CountDownLatch实现实时通信 示例代码，如下所示：\nimport java.util.ArrayList; import java.util.List; import java.util.concurrent.CountDownLatch; /** * @author xujin * */ …","date":1470747600,"description":"使用wait/notify方法实现线程间的通信。wait和notify必须配合synchronized关键字使用，wait方法释放锁，notify方法不释放锁`。","dir":"blog/bf/bf-thread-singal/","fuzzywordcount":3000,"kind":"page","lang":"zh","lastmod":1470747600,"objectID":"c077ce611f4b333883d8463f052c99ca","permalink":"/blog/bf/bf-thread-singal/","publishdate":"2016-08-09T21:00:00+08:00","readingtime":6,"relpermalink":"/blog/bf/bf-thread-singal/","summary":"1. 线程间通信概念 线程是操作系统中独立的个体，但这些个体如果不经过特殊的处理就不能成为一个整体，线程间的通信就成为整体的必用方式之一。当线程存","tags":["并发编程","多线程"],"title":"并发编程总结之线程间的通信","type":"blog","url":"/blog/bf/bf-thread-singal/","wordcount":2940},{"author":"许进","categories":"并发编程","content":" 1. 脏读 1.1 什么是脏读 对于对象的同步和异步方法，我们在设计程序，一定要考虑问题的整体性，不然会出现数据不一致的错误，最经典的错误就是脏读(DirtyRead)。\n1.2 示例Code 业务整体需要使用完整的synchronized，保持业务的原子性。\n/** * 业务整体需要使用完整的synchronized，保持业务的原子性。 * * @author xujin * */ public class DirtyRead { private String username = \u0026amp;quot;xujin\u0026amp;quot;; private String password = \u0026amp;quot;123\u0026amp;quot;; public synchronized void setValue(String username, String password) { this.username = username; try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } this.password = password; System.out.println(\u0026amp;quot;setValue最终结果：username = \u0026amp;quot; + username + \u0026amp;quot; , password = \u0026amp;quot; + password); } //①这里getValue没有加synchronized修饰 public void getValue() { System.out.println(\u0026amp;quot;getValue方法得到：username = \u0026amp;quot; + this.username + \u0026amp;quot; , password = \u0026amp;quot; + this.password); } public static void main(String[] args) throws Exception { final DirtyRead dr = new DirtyRead(); Thread t1 = new Thread(new Runnable() { @Override public void run() { dr.setValue(\u0026amp;quot;张三\u0026amp;quot;, \u0026amp;quot;456\u0026amp;quot;); } }); t1.start(); Thread.sleep(1000); dr.getValue(); } }  上面的Code中，getValue没有加synchronized修饰，打印结果如下,出现脏读\ngetValue方法得到：username = 张三 , password = 123 setValue最终结果：username = 张三 , password = 456  只需在getValue加synchronized修饰，如下:\npublic synchronized void getValue() { System.out.println(\u0026amp;quot;getValue方法得到：username = \u0026amp;quot; + this.username + \u0026amp;quot; , password = \u0026amp;quot; + this.password); }  运行结果如下,没有造成数据脏读\nsetValue最终结果：username = 张三 , password = 456 getValue方法得到：username = 张三 , password = 456  1.3 小结 在我们对对象中的一个方法加锁的时候，需要考虑业务的或程序的整体性，也就是为程序中的set和get方法同时加锁synchronized同步关键字，保证业务的(service层)的原子性，不然会出现数据错误，脏读。\n2.synchronized的重入 2.1 什么是synchronized的重入锁  synchronized,它拥有强制原子性的内置锁机制,是一个重入锁,所以在使用synchronized时,当一个线程请求得到一个对象锁后再次请求此对象锁,可以再次得到该对象锁,就是说在一个synchronized方法/块的内部调用本类的其他synchronized方法/块时，是永远可以拿到锁。 当线程请求一个由其它线程持有的对象锁时，该线程会阻塞，而当线程请求由自己持有的对象锁时，如果该锁是重入锁,请求就会成功,否则阻塞.   简单的说:关键字synchronized具有锁重入的功能，也就是在使用synchronized时，当一个线程得到一个对象锁的锁后，再次请求此对象时可以再次得到该对象对应的锁。\n 2.2 嵌套调用关系synchronized的重入 嵌套调用关系synchronized的重入也是线程安全的，下面是method1，method2，method3都被synchronized修饰，调用关系method1\u0026amp;ndash;\u0026amp;gt;method2\u0026amp;ndash;\u0026amp;gt;method3,也是线程安全的。\n/** * synchronized的重入 * * @author xujin * */ public class SyncReenTrant { public synchronized void method1() { System.out.println(\u0026amp;quot;method1..\u0026amp;quot;); method2(); } public synchronized void method2() { System.out.println(\u0026amp;quot;method2..\u0026amp;quot;); method3(); } public synchronized void method3() { System.out.println(\u0026amp;quot;method3..\u0026amp;quot;); } public static void main(String[] args) { final SyncReenTrant sd = new SyncReenTrant(); Thread t1 = new Thread(new Runnable() { @Override public void run() { sd.method1(); } }); t1.start(); }  运行结果如下:\nmethod1.. method2.. method3..  2.3 继承关系的synchronized的重入 简单 Code1：\npublic class Son extends Father { public synchronized void doSomething() { System.out.println(\u0026amp;quot;child.doSomething()\u0026amp;quot;); // 调用自己类中其他的synchronized方法 doAnotherThing(); } private synchronized void doAnotherThing() { // 调用父类的synchronized方法 super.doSomething(); …","date":1469538000,"description":"本节主要介绍了并发编程下怎么避免数据脏读和什么是synchronized的可重入锁，synchronized的可重入锁的几种使用场景下，是线程安全的。以及一些细节的synchronized使用问题和synchronized常见代码块示例Code可以直接Copy运行","dir":"blog/bf/bf-synchronized/","fuzzywordcount":4600,"kind":"page","lang":"zh","lastmod":1469538000,"objectID":"8f06d5d33e10a8b45a662d66b09b3594","permalink":"/blog/bf/bf-synchronized/","publishdate":"2016-07-26T21:00:00+08:00","readingtime":10,"relpermalink":"/blog/bf/bf-synchronized/","summary":"1. 脏读 1.1 什么是脏读 对于对象的同步和异步方法，我们在设计程序，一定要考虑问题的整体性，不然会出现数据不一致的错误，最经典的错误就是脏读(Dir","tags":["并发编程","多线程"],"title":"并发编程总结之synchronized细节问题","type":"blog","url":"/blog/bf/bf-synchronized/","wordcount":4512},{"author":"许进","categories":"并发编程","content":" 线程安全 线程安全概念  当多个线程访问访问某一个类(对象或方法)时，这个类或对象或方法始终能表现出正确的行为或我们想要的结果，那么这个类(对象或方法)就是线程安全的。 synchronized：可以在任意的对象及方法上加锁，而加锁的这段代码称之为互斥区或者临界区。\n代码示例说明1 运行main方法，main方法里有5个线程t1到t5，同一时间启动去访问MyThread类的Run方法。\n 不加synchronized关键字修饰run()方法的代码 ```java package org.xujin.multithread;\n  public class MyThread extends Thread {\nprivate int count = 5; public void run() { count--; System.out.println(this.currentThread().getName() + \u0026amp;quot; count = \u0026amp;quot; + count); } public static void main(String[] args) { /** * 分析：当多个线程访问myThread的run方法时，以排队的方式进行处理（这里排对是按照CPU分配的先后顺序而定的）， 一个线程想要执行synchronized修饰的方法里的代码： 1 尝试获得锁 2 * 如果拿到锁，执行synchronized代码体内容；拿不到锁，这个线程就会不断的尝试获得这把锁，直到拿到为止， 而且是多个线程同时去竞争这把锁。（也就是会有锁竞争的问题） */ MyThread myThread = new MyThread(); Thread t1 = new Thread(myThread, \u0026amp;quot;t1\u0026amp;quot;); Thread t2 = new Thread(myThread, \u0026amp;quot;t2\u0026amp;quot;); Thread t3 = new Thread(myThread, \u0026amp;quot;t3\u0026amp;quot;); Thread t4 = new Thread(myThread, \u0026amp;quot;t4\u0026amp;quot;); Thread t5 = new Thread(myThread, \u0026amp;quot;t5\u0026amp;quot;); t1.start(); t2.start(); t3.start(); t4.start(); t5.start(); }  }\n运行结果如下，没有出现我们想要的结果,打印出来的线程名是无序的 count值也没按正常--，运行多次不能保证count打印的值每次一致，因此出现了线程安全问题。  t1 count = 2 t2 count = 2 t5 count = 0 t3 count = 2 t4 count = 1\n### 代码示例说明2 1. 当我们加上synchronized关键字修饰run()方法后，代码如下。 ```java public class MyThread extends Thread { private int count = 5; public synchronized void run() { count--; System.out.println(this.currentThread().getName() + \u0026amp;quot; count = \u0026amp;quot; + count); } public static void main(String[] args) { /** * 分析：当多个线程访问myThread的run方法时，以排队的方式进行处理（这里排对是按照CPU分配的先后顺序而定的）， 一个线程想要执行synchronized修饰的方法里的代码： 1 尝试获得锁 2 * 如果拿到锁，执行synchronized代码体内容；拿不到锁，这个线程就会不断的尝试获得这把锁，直到拿到为止， 而且是多个线程同时去竞争这把锁。（也就是会有锁竞争的问题） */ MyThread myThread = new MyThread(); Thread t1 = new Thread(myThread, \u0026amp;quot;t1\u0026amp;quot;); Thread t2 = new Thread(myThread, \u0026amp;quot;t2\u0026amp;quot;); Thread t3 = new Thread(myThread, \u0026amp;quot;t3\u0026amp;quot;); Thread t4 = new Thread(myThread, \u0026amp;quot;t4\u0026amp;quot;); Thread t5 = new Thread(myThread, \u0026amp;quot;t5\u0026amp;quot;); t1.start(); t2.start(); t3.start(); t4.start(); t5.start(); } }   加上synchronized运行结果如下，线程名无序，无论你执行多少次程序，count\u0026amp;ndash;的值都是显示我们想要的正确结果。\nt1 count = 4 t3 count = 3 t4 count = 2 t5 count = 1 t2 count = 0  小结 当多个线程访问Mythread的run方法时，以排队的方式进行处理(排队的方式是按照CPU分配的饿先后顺序而定的)，一个线程想要执行synchronized修饰的方法里的代码，首先尝试获得锁，如果拿到锁，执行synchronized中代码体内容;拿不到锁，这个线程就会不断的尝试获得这把锁，直到拿到为止，而且是多个线程同时去竞争这把锁，也就是会有竞争锁的问题。\n  多个线程多个锁 多个线程多个锁:多个线程，每个线程都可以拿到自己指定的锁，分别获得锁之后，执行synchronized方法体的内容。\n代码示例说明1  两个线程t1,t2分别依次start，访问两个对象的synchronized修饰的printNum方法，Code如下: ```java /** 关键字synchronized取得的锁都是对象锁，而不是把一段代码（方法）当做锁， 所以代码中哪个线程先执行synchronized关键字的方法，哪个线程就持有该方法所属对象的锁（Lock），  在静态方法上加synchronized关键字，表示锁定.class类，类一级别的锁（独占.class类）。 @author xujin * */ public class MultiThread {\nprivate int num = 0;\npublic synchronized void printNum(String tag) { try {\n if (tag.equals(\u0026amp;quot;a\u0026amp;quot;)) { num = 100; System.out.println(\u0026amp;quot;tag a, set num over!\u0026amp;quot;); Thread.sleep(1000); } else { num = 200; System.out.println(\u0026amp;quot;tag b, set num over!\u0026amp;quot;); } System.out.println(\u0026amp;quot;tag \u0026amp;quot; + tag …","date":1469106000,"description":"并发编程总结之多线程基础","dir":"blog/bf/bf-multithread/","fuzzywordcount":3200,"kind":"page","lang":"zh","lastmod":1469106000,"objectID":"a5e4b5c969099b489268ea27513b6d2c","permalink":"/blog/bf/bf-multithread/","publishdate":"2016-07-21T21:00:00+08:00","readingtime":7,"relpermalink":"/blog/bf/bf-multithread/","summary":"线程安全 线程安全概念 当多个线程访问访问某一个类(对象或方法)时，这个类或对象或方法始终能表现出正确的行为或我们想要的结果，那么这个类(对象或","tags":["并发编程"],"title":"并发编程总结之多线程基础","type":"blog","url":"/blog/bf/bf-multithread/","wordcount":3188},{"author":null,"categories":null,"content":" 网关的线程模型 NIO的核心实现 NIO的核心API Buffer，channel，selecter。\nchannel与流的区别    对比 channel 流     读写 同时进行读写 只能读或者写   异步 可以异步读写    异步 通道可以写缓冲区，也可以从缓冲区读     buffer 缓冲区本质上是一个可以写入数据的内存块，然后可以再次读取，该对象提供了一组方法，可以更轻松地使用内存块，使用缓冲区读取和写入数据通常遵循以下四个步骤：\n 写数据到缓冲区；\n 调用buffer.flip()方法；\n 从缓冲区中读取数据；\n 调用buffer.clear()或buffer.compat()方法；\n  当向buffer写入数据时，buffer会记录下写了多少数据，一旦要读取数据，需要通过flip()方法将Buffer从写模式切换到读模式，在读模式下可以读取之前写入到buffer的所有数据，一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。\n 参考文章:https://www.jianshu.com/p/362b365e1bcc\n Netty的线程模型 Netty的线程模型主要有单线程Reactor模型，多线程Reactor，主从多线程Reactor模型。\nServerBootstrap bootstrap = new ServerBootstrap(); //绑定线程池 bootstrap.group(bossGroup, workGroup) .channel(NioServerSocketChannel.class) //指定使用的channel .option(ChannelOption.SO_REUSEADDR, serverConfig.isReUseAddr()) .option(ChannelOption.SO_BACKLOG, serverConfig.getBackLog()) .childOption(ChannelOption.SO_RCVBUF, serverConfig.getRevBuf()) .childOption(ChannelOption.SO_SNDBUF, serverConfig.getSndBuf()) .childOption(ChannelOption.TCP_NODELAY, serverConfig.isTcpNoDelay()) .childOption(ChannelOption.SO_KEEPALIVE, serverConfig.isKeepalive()) .childHandler(initChildHandler());  查看Netty的源码io.netty.bootstrap.ServerBootstrap.java，知道如下:\n/** * Specify the {@link EventLoopGroup} which is used for the parent (acceptor) and the child (client). * 这里的单参数即为连接与请求处理线程-是公用的线程池 */ @Override public ServerBootstrap group(EventLoopGroup group) { return group(group, group); } /** * Set the {@link EventLoopGroup} for the parent (acceptor) and the child (client). These * {@link EventLoopGroup}\u0026#39;s are used to handle all the events and IO for {@link ServerChannel} and * {@link Channel}\u0026#39;s. */ public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup) { super.group(parentGroup); ObjectUtil.checkNotNull(childGroup, \u0026amp;quot;childGroup\u0026amp;quot;); if (this.childGroup != null) { throw new IllegalStateException(\u0026amp;quot;childGroup set already\u0026amp;quot;); } this.childGroup = childGroup; return this; }   当 EventLoopGroup bossGroup = new NioEventLoopGroup()不填值时，默认为cpu核数*2 当 EventLoopGroup bossGroup = new NioEventLoopGroup()不填值时，默认为cpu核数*2  ","date":-62135596800,"description":"","dir":"blog/mw/janus/","fuzzywordcount":200,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"093403deffc17a0cb69cd8b9428a4719","permalink":"/blog/mw/janus/1/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/blog/mw/janus/1/","summary":"网关的线程模型 NIO的核心实现 NIO的核心API Buffer，channel，selecter。\nchannel与流的区别    对比 channel 流     读写 同时进行读写 只能读或者写   异步 可以异步读写    异步 通道可以写缓冲区，也可以从缓冲区读     buffer 缓冲区本质上是一个可以写入数据的内存块，然后可以再次读取，该对象提供了一组方法，可以更轻松地使用内存块，使用缓冲区读取和写入数据通常遵循以下四个步骤：\n 写数据到缓冲区；\n 调用buffer.flip()方法；\n 从缓冲区中读取数据；\n 调用buffer.clear()或buffer.compat()方法；\n  当向buffer写入数据时，buffer会记录下写了多少数据，一旦要读取数据，需要通过flip()方法将Buffer从写模式切换到读模式，在读模式下可以读取之前写入到buffer的所有数据，一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。\n 参考文章:https://www.jianshu.com/p/362b365e1bcc\n Netty的线程模型 Netty的线程模型主要有单线程Reactor模型，多线程Reactor，主从多线程Reactor模型。\nServerBootstrap bootstrap = new ServerBootstrap(); //绑定线程池 bootstrap.group(bossGroup, workGroup) .channel(NioServerSocketChannel.class) //指定使用的channel .option(ChannelOption.SO_REUSEADDR, serverConfig.isReUseAddr()) .option(ChannelOption.SO_BACKLOG, serverConfig.getBackLog()) .childOption(ChannelOption.SO_RCVBUF, serverConfig.getRevBuf()) .childOption(ChannelOption.SO_SNDBUF, serverConfig.getSndBuf()) .childOption(ChannelOption.TCP_NODELAY, serverConfig.isTcpNoDelay()) .","tags":null,"title":"","type":"blog","url":"/blog/mw/janus/1/","wordcount":153},{"author":null,"categories":null,"content":" 1.Halo Settings 1.1 Halo Server设置 Halo ToolKit支持自定义Halo框架对应的代码生成器服务端和Halo Admin可视化中台管控服务端，如下图所示:\n 主要方便内网部署服务端和使用本地的服务端\n 1.2 halo Config设置 Halo Config是一个Halo Tools提供的IDEA插件配置选项，目前支持是否开启行标记。如下图所示:\n1.3 Data Source设置 Halo ToolKit支持对Mysql数据库数据源的的增加，删除，测试连接的管理存储，方便在IDEA插件需要使用的地方直接选择即可，如下图所示:\n","date":-62135596800,"description":"","dir":"projects/halo-toolkit/halo-settings/","fuzzywordcount":300,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"00285e737a11bf9f972f35b3f06dfd93","permalink":"/projects/halo-toolkit/halo-settings/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/halo-toolkit/halo-settings/","summary":"1.Halo Settings 1.1 Halo Server设置 Halo ToolKit支持自定义Halo框架对应的代码生成器服务端和Halo Admin可视化中台管控服务端，如下图所示: 主","tags":null,"title":"Halo Settings功能","type":"projects","url":"/projects/halo-toolkit/halo-settings/","wordcount":229},{"author":null,"categories":null,"content":" Halo ToolKit增强右键 Halo ToolKit提供右键增强功能，帮助开发快速创建常用的Java类，提高开发效率。如下图所示:\n如下图所示，右键支持创建13种Java类，包括创建实体，域服务，流程，资源库，Controller等\n","date":-62135596800,"description":"","dir":"projects/halo-toolkit/right-create/","fuzzywordcount":200,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"c0144ff674b9b2dd8b0ec62f2f74d2dd","permalink":"/projects/halo-toolkit/right-create/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/halo-toolkit/right-create/","summary":"Halo ToolKit增强右键 Halo ToolKit提供右键增强功能，帮助开发快速创建常用的Java类，提高开发效率。如下图所示: 如下图所示，右键支持创","tags":null,"title":"Halo ToolKit右键创建功能","type":"projects","url":"/projects/halo-toolkit/right-create/","wordcount":109},{"author":null,"categories":null,"content":" 1. Halo Toolkit概述 Enhances Your Productivity When Developing Applications Based on Halo Framework\n2. Halo ToolKit功能 Halo ToolKit是一款IDEA插件，只为加速Halo应用开发而生。目前主要包含如下功能:\n 1、支持向导式快速搭建中台应用和传统应用 2、在应用Spring Application启动入口程序中中点击@Domain前面的图标可快速维护应用和中台业务域的关系 3、Halo Reference中的Halo Server支持自定义代码生成器服务端和Halo Admin中台可视化服务端URL 4、Halo Reference中的Data Source支持对数据源进行管理 5、Halo Reference中的Halo Config支持对插件的功能进行关闭和打开 6、右键支持创建13种Java类，包括创建实体，域服务，流程，资源库，Controller等 7、右键创建数据对象支持选择数据库连接和向导式创建工程支持选择数据库连接  3.安装 安装如下图所示: ","date":-62135596800,"description":"","dir":"projects/halo-toolkit/overview/","fuzzywordcount":400,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"a81bdd3e85fde792bd8d3ecdb743a104","permalink":"/projects/halo-toolkit/overview/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/halo-toolkit/overview/","summary":"1. Halo Toolkit概述 Enhances Your Productivity When Developing Applications Based on Halo Framework 2. Halo ToolKit功能 Halo ToolKit是一款IDEA插件，只为加速Halo应用开发而生。目前主要包","tags":null,"title":"Halo ToolKit概述","type":"projects","url":"/projects/halo-toolkit/overview/","wordcount":390},{"author":null,"categories":null,"content":" 1.行标记功能 1.1 @Domain行标记修改 Halo框架所创建的应用需要管中台可视化纳管，因此当应用启动的时候会判断当前应用是否属于某个域，不属于某个域将停止启动，Halo ToolKit提供一个快速修改编辑的功能。如下图所示: ","date":-62135596800,"description":"","dir":"projects/halo-toolkit/line-marker/","fuzzywordcount":200,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"07ac005d64b05d5421f23e789fc5bb05","permalink":"/projects/halo-toolkit/line-marker/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/halo-toolkit/line-marker/","summary":"1.行标记功能 1.1 @Domain行标记修改 Halo框架所创建的应用需要管中台可视化纳管，因此当应用启动的时候会判断当前应用是否属于某个域，不属","tags":null,"title":"Halo ToolKit行标记功能","type":"projects","url":"/projects/halo-toolkit/line-marker/","wordcount":111},{"author":null,"categories":null,"content":" 1. 概述 使用Halo Toolkit可以帮助您快速创建Halo工程，无需通过第三方客户端操作，可以直接帮助您快速上手，加速代码开发，提高开发效率。\n2. 前提条件 在IntelliJ IDEA中安装和配置Halo Toolkit。\n3.创建工程步骤 3.1 选择应用类型创建工程  在IntelliJ IDEA菜单栏选择File \u0026amp;gt; New \u0026amp;gt; Project。 在New Project页面左侧导航栏单击Halo。  3.2 配置工程基本信息 在New Project页面配置相关参数，单击Next。\n3.3 数据库相关配置 如果需要根据表生成数据对象，可以进行数据库相关配置 3.4 点击Finish生成工程 ","date":-62135596800,"description":"","dir":"projects/halo-toolkit/create-project/","fuzzywordcount":300,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"ecec2625a1e92085ba9a1885d695c1ff","permalink":"/projects/halo-toolkit/create-project/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/halo-toolkit/create-project/","summary":"1. 概述 使用Halo Toolkit可以帮助您快速创建Halo工程，无需通过第三方客户端操作，可以直接帮助您快速上手，加速代码开发，提高开发效率","tags":null,"title":"Halo Toolkit创建工程功能","type":"projects","url":"/projects/halo-toolkit/create-project/","wordcount":266},{"author":null,"categories":null,"content":" 1.背景 使用IDEA或者其它IDE集成开发工具，无论写Java代码还是其它代码都需要很多右键操作，比如包上右键创建Java类，IDEA提供的包右键创建Java类，只是创建一个只有类名的空Java文件。 而Java开发有很多重复性工作，比如Controller类上面加注解，或者基于Mybatis或Mybatis Plus去生成数据对象或者Mapper都是重复性工作。此时类似的功能，就需要通过右键功能解决。本文介绍的就是包右键功能定制开发。\n2.IDEA包右键 IDEA包右键,就是在所在包上面右键创建自己定制的过的文件模板，生成自己需要生成的Java类，加速开发。如下图所示:\n3. 开发IDEA插件 3.1 增加扩展点到IDEA插件中 在plugin.xml中，增加Actions，如下代码所示:\n\u0026amp;lt;actions\u0026amp;gt; \u0026amp;lt;group id=\u0026amp;quot;Halo Tools\u0026amp;quot; text=\u0026amp;quot;Halo Tool\u0026amp;quot; ➊ popup=\u0026amp;quot;true\u0026amp;quot; icon=\u0026amp;quot;/icons/halo.png\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;add-to-group group-id=\u0026amp;quot;ProjectViewPopupMenu\u0026amp;quot; anchor=\u0026amp;quot;after\u0026amp;quot; relative-to-action=\u0026amp;quot;ReplaceInPath\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;/group\u0026amp;gt; \u0026amp;lt;!-- 创建Halo Basic --\u0026amp;gt; \u0026amp;lt;action class=\u0026amp;quot;org.xujin.idea.right.NewBasicExeAction\u0026amp;quot; ➋ id=\u0026amp;quot;halo.basic.class\u0026amp;quot; description=\u0026amp;quot;Halo Basic\u0026amp;quot; icon=\u0026amp;quot;/icons/right/HaloBasic.png\u0026amp;quot; text=\u0026amp;quot;Basic Class\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;add-to-group group-id=\u0026amp;quot;Halo Tools\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;/action\u0026amp;gt; \u0026amp;lt;/actions\u0026amp;gt;  ➊ 在右键分组，并设置右键位置在添加到ReplaceInPath之后后 ➋ 添加右键子分组到Halo Tools中。\n3.1 开发对应的Action 右键点击之后，显示右键功能分组，点击右键分组将会触发一个Action，可以对Action定制是开会话框，还是开向导式方式创建Java类。\n/** * 右键创建Basic Action * @author xujin */ public class NewBasicExeAction extends AnAction { @Override public void actionPerformed(AnActionEvent e) { Project project = e.getProject(); /** * 从Action中得到一个虚拟文件 */ VirtualFile virtualFile = e.getData(DataKeys.VIRTUAL_FILE); if (!virtualFile.isDirectory()) { virtualFile = virtualFile.getParent(); } Module module = ModuleUtil.findModuleForFile(virtualFile, project); String moduleRootPath = ModuleRootManager.getInstance(module).getContentRoots()[0].getPath(); String actionDir = virtualFile.getPath(); String str = StringUtils.substringAfter(actionDir, moduleRootPath + \u0026amp;quot;/src/main/java/\u0026amp;quot;); //获取右键后的路径 String basePackage = StringUtils.replace(str, \u0026amp;quot;/\u0026amp;quot;, \u0026amp;quot;.\u0026amp;quot;); NewRightContext.clearAllSet(); NewRightContext.setSelectedPackage(basePackage); BasicActionOpenDialog dialog = new BasicActionOpenDialog(project, module); if (!dialog.showAndGet()) { return; } DumbService.getInstance(project).runWhenSmart((DumbAwareRunnable) () -\u0026amp;gt; new WriteCommandAction(project) { @Override protected void run(@NotNull Result result) { switch (NewRightContext.getClassType()) { case HaloConstant.COMBOX_CONTROLLER: createByFtl(project, moduleRootPath,\u0026amp;quot;Controller.java.ftl\u0026amp;quot;); break; } MavenProjectsManager manager = MavenProjectsManager.getInstance(project); //解决依赖 manager.forceUpdateAllProjectsOrFindAllAvailablePomFiles(); //优化生成的所有Java类 HaloIdeaUtils.doOptimize(project); } }.execute()); } /** * 通过ftl创建 Controller * @param project * @param moduleRootPath */ private void createByFtl(Project project, String moduleRootPath, String ftlName) { NewRightModel newRightModel= NewRightContext.copyToNewRightModel(); try { PisFileByFreeMarkerUtil.createFile(project, newRightModel, moduleRootPath,ftlName); NewRightContext.clearAllSet(); } catch (Exception ex) { ex.printStackTrace(); } } }   更多内容请下载代码，自行Debug查看。\n ","date":-62135596800,"description":"IDEA插件-添加右键菜单 ","dir":"guides/idea-01/","fuzzywordcount":800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"2c09bbf8567719f35f684f9d554c7d00","permalink":"/guides/idea-01/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/guides/idea-01/","summary":"1.背景 使用IDEA或者其它IDE集成开发工具，无论写Java代码还是其它代码都需要很多右键操作，比如包上右键创建Java类，IDEA提供的","tags":null,"title":"IDEA插件-添加右键菜单","type":"guides","url":"/guides/idea-01/","wordcount":735},{"author":null,"categories":null,"content":" 1.行标记 1.1 行标记概述 IDEA源码编辑代码区域，可以编辑代码。大家肯定看到行上面有一些图标，其实我们也可以定义自己的行标记结合自己的需要弹窗修改代码或进行导航。\nHalo框架所创建的应用需要管中台可视化纳管，因此当应用启动的时候会判断当前应用是否属于某个域，不属于某个域将停止启动，HaloTools提供一个快速修改编辑的功能。@Domain注解行标记修改,如下图所示: 1.2 开发一个行标记  1.在plugin.xml中添加行标记扩展配置,如下代码所示：  \u0026amp;lt;extensions defaultExtensionNs=\u0026amp;quot;com.intellij\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;!--如下所示添加行标记扩展 --\u0026amp;gt; \u0026amp;lt;codeInsight.lineMarkerProvider language=\u0026amp;quot;JAVA\u0026amp;quot; implementationClass=\u0026amp;quot;org.xujin.idea.right.linemarker.HaloLineMarker\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;/extensions\u0026amp;gt;   2.创建HaloLineMarker.java，代码如下所示:  public class HaloLineMarker implements LineMarkerProvider { @Nullable @Override public LineMarkerInfo getLineMarkerInfo(@NotNull PsiElement psiElement) { LineMarkerInfo lineMarkerInfo= null; try { lineMarkerInfo = null; String anno=\u0026amp;quot;org.springframework.boot.autoconfigure.SpringBootApplication\u0026amp;quot;; if(!judgeHaveAnnotation(psiElement,anno)){ return lineMarkerInfo; } PsiClassImpl field = ((PsiClassImpl) psiElement); PsiAnnotation psiAnnotation = field.getAnnotation(anno); lineMarkerInfo = new LineMarkerInfo\u0026amp;lt;\u0026amp;gt;(psiAnnotation, psiAnnotation.getTextRange(), IconLoader.findIcon(\u0026amp;quot;/icons/right/HaloBasic.png\u0026amp;quot;), new FunctionTooltip(\u0026amp;quot;快速导航\u0026amp;quot;), new AppMgmtNavigationHandler(),// ➊ GutterIconRenderer.Alignment.LEFT); } catch (Exception e) { e.printStackTrace(); // ➋ } return lineMarkerInfo; } @Override public void collectSlowLineMarkers(@NotNull List\u0026amp;lt;PsiElement\u0026amp;gt; list, @NotNull Collection\u0026amp;lt;LineMarkerInfo\u0026amp;gt; collection) { } private boolean judgeHaveAnnotation(@NotNull PsiElement psiElement, String anno) { if (psiElement instanceof PsiClass) { PsiClassImpl field = ((PsiClassImpl) psiElement); PsiAnnotation psiAnnotation = field.getAnnotation(anno); if (null != psiAnnotation) { return true; } return false; } return false; } }  ➊ 添加行标记点击之后处理的Handler。\n➋ ((PsiClassImpl) psiElement)会出现异常，因此进行try-catch处理,代码仅做案例演示\n 上述代码，仅作为代码案例展示。离实际项目还有优化空间，本案例代码:https://github.com/SoftwareKing/idea-study/tree/master/idea-study-02。\n  3.启动IDEA插件模拟器debug，可以看到如下图所示，行标记处理成功。  ","date":-62135596800,"description":"IDEA源码编辑代码区域，可以编辑代码。其实我们可以定义自己的行标记,结合自己的需要弹窗修改代码或进行导航 ","dir":"guides/idea-02/","fuzzywordcount":700,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"9b87e08854f859b29ee567d59b607fee","permalink":"/guides/idea-02/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/guides/idea-02/","summary":"1.行标记 1.1 行标记概述 IDEA源码编辑代码区域，可以编辑代码。大家肯定看到行上面有一些图标，其实我们也可以定义自己的行标记结合自己的需要弹窗","tags":null,"title":"IDEA插件-自定义行标记开发","type":"guides","url":"/guides/idea-02/","wordcount":624},{"author":null,"categories":null,"content":" 1.什么是Moss 1.1 什么是服务治理 服务治理，我也称之为微服务治理，是指用来管理微服务的整个生命周期。包括应用的创建，服务名的规范，服务的上下线，服务的迁移，整个服务的生老病死等方方面面的治理。\n1.2 Moss概述 Moss(莫斯)是服务治理平台的代号，取名灵感来自电影《流浪地球》中的莫斯(Moss),Moss是电影《流浪地球》中领航员号空间站的人工智能机器人-负责管理空间站所有事务以及流浪地球的计划，而Moss跟Boos一样，是所有微服务的老板，所有微服务的生命周期将归其统管。\n为什么会出现Moss？因为基于Spring Cloud的微服务体系，缺乏统一的可视化的纳管治理平台。\n Spring Cloud中国社区从2017年11月份，开始规划Spring Cloud Admin的开发和设计，专注于研究这个领域。 代码地址:https://github.com/SpringCloud/Moss\n #### 1.2.1 竞品分析\nMoss的竞品分析对比如下表所示:\n   对比选项 Spring Boot Admin Moss     服务画像 ❌ ✅   服务实例画像 ☑️ ✅   支持单Eureka ☑️ ✅   支持单Nacos ☑️ ✅   支持多Eureka，在线动态增加，删除,切换 ❌️ ✅   前端技术 Vue Ant Design Pro   支持Spring Boot 1.5.X和Spring Boot 2.0.X ☑️ ✅   服务调用拓扑 ❌ ✅   在线查看Jar依赖 ❌ ✅   服务归属(项目，Owner) ❌ ✅   服务和实例支持模糊查询 ❌ ✅   服务闪烁告警 ❌ ✅   服务评分打星 ❌ ✅   服务列表画像 ❌ ✅   服务实例列表画像 ❌ ✅   服务实例内部组件列表，使用哪些Spring Cloud组件 ❌ ✅     其中☑️表示功能相对较弱 ✅表示功能完整强大 ❌表示功能缺失\n 1.2.1 Moss RoadMap Roadmap 时间点：\n✅表示当前稳定可用版本\n   版本 Milestone 主要特性     ✅1.0.0.RELEASE 2019.4.21 稳定可用版本    1.2.2 Moss开发团队    姓名 角色 github地址     SoftwareKing Owner https://github.com/SoftwareKing   iShawnWang 前端开发 https://github.com/iShawnWang    1.3 Moss的功能  Moss的功能包括服务画像，服务实例画像，服务上下线事件记录，服务上下线websocket消息通知，针对生产应用可配置多种服务上线通知工具，支持多种注册中心，比如Eureka，Consul，Nacos.支持动态连接注册中心进去切换进行服务治理操作。  1.3.1 服务画像  服务画像:  服务概要信息-包括服务实例数，UP数，DOWN数，OffLine数，服务归属的项目，归属的Owner等。 服务健康指标-展示服务的健康信息 服务请求映射-展示出服务对外提供的所有REST接口 服务调用链-展示服务的依赖调用拓扑 服务API监控-通过http trace和全链路监控对API进行监控 服务内部组件状态-内部组件的依赖，使用版本状态 服务性能指标-对服务进行QPS，性能指标收集打分 服务评级-自动根据评级规则对服务进行跑批评分打星。     PS: Spring Boot Admin服务墙，如上图所示，看完之后谁能告诉我，它的服务画像能画出什么来。 Moss的服务画像列表如下所示，对比显而易见！\n 1.3.2 服务实例画像  服务实例画像\n 实例调用拓扑-对接Skywalking，PinPoint等获取实例调用拓扑  实例Build信息-实例构建信息  实例Git提交信息-最后一次提交人的Git详细信息  Spring Cloud使用功能列表 实例的健康信息 实例的上下线Event信息  服务日志级别-查看应用的日志级别,根据需要调整日志级别打印对应日志级别的信息  环境配置-查看当前应用的环境配置信息 实例JMX信息-分类展示实例的JMX信息  查看JVM-实时展示应用实例的内存使用情况，GC次数，以及CPU和内存使用率  查看日志-增量实时获取应用的info日志或Error日志  查看线程-查看当前实例的线程情况  查看实例内部依赖-查看实例的内部Jar依赖情况，统计分析展示依赖拓扑等  HttpTrace-按时间展示http请求的轨迹信息，包括请求的路径，Response的状态，调用耗时等     支持GC Log日志查看   1.3.3 服务纳管 项目对应多个应用，每个应用由多个实例组成提供具体的服务，服务的生命周期管理需要可控，可追溯，可监控，可规范。 由Spring Cloud体系构建的微服务体系，应用名即服务名。服务纳管分为历史应用纳管和新应用纳管。\n 新应用纳管: 新应用使用Moss-Client，启动时连接Moss对应用名进行统一拦截check，从而规范应用名。 旧应用纳管: 旧应用引入对应的版本的Moss-Client，在Moss平台对其手动接入管理，录入应用名。  1.3.4 多注册中心支持 Moss通过注册中心接管Spring Cloud体系的微服务。支持动态连接注册中心，填注册中心的URL即可，快速接管服务。\n1.3.5 服务报表数据 Moss通过注册中心接管Spring Cloud体系的微服务。然后获取每个服务使用Spring Boot的版本和Spring Cloud的版本，Moss的接入率以报表数据展示。\n1.3.6 事件日志 1.3.7 元数据管理 1.3.9 Spring Cloud组件使用情况 2.Moss的架构设计 2.1 Moss的架构设计 Moss基于Spring Boot Admin 2.1.3版中的spring-boot-admin-server模块二次开发，基于可扩展思想。前端采用Ant Design Pro，采用Spring Boot+shiro+JWT+LDAP实现整个权限认证管理。通过Moss-Cloud-Adapter模块支持多注册中心，应用启动对应用名进行check是否规范。\n 实现细节后续补充\n 2.2 Moss的服务设计 Moss服务端主要自动探测EndPoint，代理EndPoint，对接各种注册中心，提供可视化的管理。\n2.3 Moss的客户端设计 moss客户端主要用于内置预设自研端点和管理配置信息，使接入方无感知接入。 \u0026amp;gt;实现细节后续补充\n2.3.1 Moss-Client Moss客户端支持两种Spring Boot版本，分别是Spring Boot 1.5.X和Spring Boot 2.X，使用只需引入moss-client-starter即可。示例2.x的客户端如下所示。\n1.引入moss-client-starter\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.xujin.moss\u0026amp;lt;/groupId\u0026amp;gt; …","date":-62135596800,"description":"","dir":"projects/moss/overview/","fuzzywordcount":3300,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"2d9d19f8650bf36febacb47972512b05","permalink":"/projects/moss/overview/","publishdate":"0001-01-01T00:00:00Z","readingtime":7,"relpermalink":"/projects/moss/overview/","summary":"1.什么是Moss 1.1 什么是服务治理 服务治理，我也称之为微服务治理，是指用来管理微服务的整个生命周期。包括应用的创建，服务名的规范，服务的上下","tags":null,"title":"Moss(莫斯) 介绍","type":"projects","url":"/projects/moss/overview/","wordcount":3212},{"author":null,"categories":null,"content":" 摘要:本文主要讲解如何将Spring Boot Admin与Spring Cloud Alibaba中的spring-cloud-starter-alibaba-nacos-discovery进行整合使用。\n1. 整合概述 通过搭建一个Spring Boot Admin Server，并将其通过spring-cloud-starter-alibaba-nacos-discovery注册到Nacos Server中即可。 源码工程地址为:https://github.com/SoftwareKing/sba-nacos\n 说明本文使用的Spring Boot Admin的版本为2.1.2，Spring Cloud的版本为Greenwich.RELEASE，Spring Cloud Alibaba的版本为0.2.1.RELEASE。至于其它版本，请读者自行适配处理。\n 2. 创建sba-nacos工程 1.创建sba-nacos工程，添加maven依赖如下所示:\n\u0026amp;lt;?xml version=\u0026amp;quot;1.0\u0026amp;quot; encoding=\u0026amp;quot;UTF-8\u0026amp;quot;?\u0026amp;gt; \u0026amp;lt;project xmlns=\u0026amp;quot;http://maven.apache.org/POM/4.0.0\u0026amp;quot; xmlns:xsi=\u0026amp;quot;http://www.w3.org/2001/XMLSchema-instance\u0026amp;quot; xsi:schemaLocation=\u0026amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;modelVersion\u0026amp;gt;4.0.0\u0026amp;lt;/modelVersion\u0026amp;gt; \u0026amp;lt;parent\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-parent\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.1.2.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/parent\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.xujin.moss\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sba-nacos\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;properties\u0026amp;gt; \u0026amp;lt;spring.boot.admin.version\u0026amp;gt;2.1.2\u0026amp;lt;/spring.boot.admin.version\u0026amp;gt; \u0026amp;lt;/properties\u0026amp;gt; \u0026amp;lt;dependencyManagement\u0026amp;gt; \u0026amp;lt;dependencies\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-dependencies\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;Greenwich.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;type\u0026amp;gt;pom\u0026amp;lt;/type\u0026amp;gt; \u0026amp;lt;scope\u0026amp;gt;import\u0026amp;lt;/scope\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-alibaba-dependencies\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;0.2.1.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;type\u0026amp;gt;pom\u0026amp;lt;/type\u0026amp;gt; \u0026amp;lt;scope\u0026amp;gt;import\u0026amp;lt;/scope\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;/dependencies\u0026amp;gt; \u0026amp;lt;/dependencyManagement\u0026amp;gt; \u0026amp;lt;dependencies\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-actuator\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-alibaba-nacos-discovery\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;de.codecentric\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-admin-starter-server\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${spring.boot.admin.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-web\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.jolokia\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;jolokia-core\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;/dependencies\u0026amp;gt; \u0026amp;lt;build\u0026amp;gt; \u0026amp;lt;finalName\u0026amp;gt;sba-nacos\u0026amp;lt;/finalName\u0026amp;gt; \u0026amp;lt;plugins\u0026amp;gt; \u0026amp;lt;plugin\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-maven-plugin\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/plugin\u0026amp;gt; \u0026amp;lt;/plugins\u0026amp;gt; \u0026amp;lt;/build\u0026amp;gt; \u0026amp;lt;/project\u0026amp;gt;   创 …","date":-62135596800,"description":"本文主要讲解如何将Spring Boot Admin与Spring Cloud Alibaba中的spring-cloud-starter-alibaba-nacos-discovery进行整合使用","dir":"guides/sba-nacos/","fuzzywordcount":1100,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"bc2998d12b565d711c797ece64e9c57b","permalink":"/guides/sba-nacos/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/guides/sba-nacos/","summary":"摘要:本文主要讲解如何将Spring Boot Admin与Spring Cloud Alibaba中的spring-cloud-starter-alibaba-","tags":null,"title":"Spring Boot Admin和Nacos集成","type":"guides","url":"/guides/sba-nacos/","wordcount":1075},{"author":null,"categories":null,"content":" 1.权重路由 1.1 权重路由使用场景 在开发或者测试的时候，或者线上发布，线上服务多版本控制的时候，需要对服务提供权重路由，最常见的使用就是，一个服务有两个版本，旧版本V1，新版本v2。在线上灰度的时候，需要通过网关动态实时推送，路由权重信息。比如95%的流量走服务v1版本，5%的流量走服务v2版本。\n issue: The Spring Cloud Gateway issue of Allow Rolling Deployments https://github.com/spring-cloud/spring-cloud-gateway/issues/67\n 1.2 Spring Cloud Gateway权重路由原理 Spring Cloud Gateway中提供了org.springframework.cloud.gateway.handler.predicate.WeightRoutePredicateFactory去实现根据分组设置权重进行路由，因此使用起来相对比较简单，有兴趣的可以debug阅读源码。\npublic class WeightRoutePredicateFactory extends AbstractRoutePredicateFactory\u0026amp;lt;WeightConfig\u0026amp;gt; implements ApplicationEventPublisherAware { private static final Log log = LogFactory.getLog(WeightRoutePredicateFactory.class); public static final String GROUP_KEY = WeightConfig.CONFIG_PREFIX + \u0026amp;quot;.group\u0026amp;quot;; public static final String WEIGHT_KEY = WeightConfig.CONFIG_PREFIX + \u0026amp;quot;.weight\u0026amp;quot;; private ApplicationEventPublisher publisher; public WeightRoutePredicateFactory() { super(WeightConfig.class); } @Override public void setApplicationEventPublisher(ApplicationEventPublisher publisher) { this.publisher = publisher; } @Override public List\u0026amp;lt;String\u0026amp;gt; shortcutFieldOrder() { return Arrays.asList(GROUP_KEY, WEIGHT_KEY); } @Override public String shortcutFieldPrefix() { return WeightConfig.CONFIG_PREFIX; } @Override public void beforeApply(WeightConfig config) { if (publisher != null) { publisher.publishEvent(new WeightDefinedEvent(this, config)); } } @Override public Predicate\u0026amp;lt;ServerWebExchange\u0026amp;gt; apply(WeightConfig config) { return exchange -\u0026amp;gt; { Map\u0026amp;lt;String, String\u0026amp;gt; weights = exchange.getAttributeOrDefault(WEIGHT_ATTR, Collections.emptyMap()); String routeId = exchange.getAttribute(GATEWAY_PREDICATE_ROUTE_ATTR); // all calculations and comparison against random num happened in // WeightCalculatorWebFilter String group = config.getGroup(); if (weights.containsKey(group)) { String chosenRoute = weights.get(group); if (log.isTraceEnabled()) { log.trace(\u0026amp;quot;in group weight: \u0026amp;quot;+ group + \u0026amp;quot;, current route: \u0026amp;quot; + routeId +\u0026amp;quot;, chosen route: \u0026amp;quot; + chosenRoute); } return routeId.equals(chosenRoute); } return false; }; } }  2.Spring Cloud Gateway中的权重路由案例 2.1 案例代码地址 https://github.com/SoftwareKing/sc-gateway/tree/master/ch4\n2.2 Spring Cloud Gateway Server说明 Spring Cloud Gateway will dispatch 95% of the requests to version 1 and 5% of the traffic to version 2 of a specified service, as shown by the following figure.\n我们通过在Spring Cloud Gateway中会配置不同的权重信息到不同URL上，Spring Cloud Gateway会根据我们配置的路由权重信息，将请求分发到不同的源服务组，权重信息如ch4/ch4-gateway中的application.yml所示，主要配置信息如下。\nspring: application: name: ch4-gateway cloud: gateway: routes: - id: service1_v1 uri: http://localhost:8081/v1 predicates: - Path=/test - Weight=service1, 95 - id: service1_v2 uri: http://localhost:8081/v2 predicates: - Path=/test - Weight=service1, 5   Weight=service1, 95，Weight=service1, 5就是路由的权重信息。\n 2.3 源服务 源服务在本案例中源服务如ch4-service-provider所示，主要提提供Gateway Server权重路由对应的后端源服务。因为比较简单因此不做详细说明，主要代码如下所示。 …","date":-62135596800,"description":"Spring Cloud Gateway的权重路由","dir":"guides/sc-gw-01/","fuzzywordcount":1000,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"40cf805761911f0efd6ac46a334b019a","permalink":"/guides/sc-gw-01/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/guides/sc-gw-01/","summary":"1.权重路由 1.1 权重路由使用场景 在开发或者测试的时候，或者线上发布，线上服务多版本控制的时候，需要对服务提供权重路由，最常见的使用就是，一个服","tags":null,"title":"Spring Cloud Gateway的权重路由","type":"guides","url":"/guides/sc-gw-01/","wordcount":946}]